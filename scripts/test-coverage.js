/** * Test Coverage Analysis Script * Phase 1: Testing Infrastructure Expansion * * Analyzes test coverage across the codebase and generates reports */ const fs = require('fs'); const path = require('path'); const { execSync } = require('child_process'); const ROOT = path.join(__dirname, '..'); const JS_DIR = path.join(ROOT, 'js'); const API_DIR = path.join(ROOT, 'api'); const TESTS_DIR = path.join(ROOT, 'tests'); // Files to exclude from coverage const EXCLUDE_PATTERNS = [ /node_modules/, /\.min\.js$/, /dist\//, /test\.js$/, /\.spec\.js$/, /\.test\.js$/, ]; // Critical files that must have tests const CRITICAL_FILES = [ 'js/main.js', 'js/auth-ui.js', 'js/achievements.js', 'js/leaderboards.js', 'js/challenges.js', 'js/store-system.js', 'api/auth.js', 'api/store.js', 'api/subscriptions.js', 'server.js', ]; /** * Walk directory and collect all JS files */ function walkDir(dir, out = []) { if (!fs.existsSync(dir)) return out; const entries = fs.readdirSync(dir, { withFileTypes: true }); for (const entry of entries) { const fp = path.join(dir, entry.name); if (entry.isDirectory()) { walkDir(fp, out); } else if (entry.name.endsWith('.js') && !EXCLUDE_PATTERNS.some(p => p.test(fp))) { out.push(fp); } } return out; } /** * Get all test files */ function getTestFiles() { const testFiles = []; if (fs.existsSync(TESTS_DIR)) { const entries = fs.readdirSync(TESTS_DIR, { withFileTypes: true }); for (const entry of entries) { if (entry.name.endsWith('.test.js') || entry.name.endsWith('.spec.js')) { testFiles.push(path.join(TESTS_DIR, entry.name)); } } // Check e2e directory const e2eDir = path.join(TESTS_DIR, 'e2e'); if (fs.existsSync(e2eDir)) { const e2eEntries = fs.readdirSync(e2eDir, { withFileTypes: true }); for (const entry of e2eEntries) { if (entry.name.endsWith('.spec.js') || entry.name.endsWith('.test.js')) { testFiles.push(path.join(e2eDir, entry.name)); } } } } return testFiles; } /** * Analyze a single JS file for testability */ function analyzeFile(filePath) { const content = fs.readFileSync(filePath, 'utf8'); const relativePath = path.relative(ROOT, filePath); // Count functions const functionMatches = content.match(/function\s+\w+|const\s+\w+\s*=\s*(?:async\s*)?\(|=>\s*{|class\s+\w+/g) || []; const functionCount = functionMatches.length; // Count exports const exportMatches = content.match(/module\.exports|export\s+(?:default\s+)?|exports\.\w+/g) || []; const exportCount = exportMatches.length; // Check for existing test file const baseName = path.basename(filePath, '.js'); const testFileName = `${baseName}.test.js`; const specFileName = `${baseName}.spec.js`; const hasTest = fs.existsSync(path.join(TESTS_DIR, testFileName)) || fs.existsSync(path.join(TESTS_DIR, specFileName)); // Check for API endpoints (for API files) const apiEndpointMatches = content.match(/router\.(get|post|put|delete|patch)\s*\(/g) || []; const apiEndpointCount = apiEndpointMatches.length; return { path: relativePath, functionCount, exportCount, hasTest, apiEndpointCount, isCritical: CRITICAL_FILES.includes(relativePath.replace(/\\/g, '/')), }; } /** * Generate coverage report */ function generateReport() { console.log('='.repeat(60)); console.log('ScaryGamesAI - Test Coverage Analysis'); console.log('Phase 1: Testing Infrastructure Expansion'); console.log('='.repeat(60)); // Collect all source files const jsFiles = walkDir(JS_DIR); const apiFiles = walkDir(API_DIR); const allFiles = [...jsFiles, ...apiFiles]; // Analyze each file const analysis = allFiles.map(analyzeFile); // Calculate statistics const totalFiles = analysis.length; const filesWithTests = analysis.filter(f => f.hasTest).length; const criticalFiles = analysis.filter(f => f.isCritical); const criticalWithTests = criticalFiles.filter(f => f.hasTest).length; const totalFunctions = analysis.reduce((sum, f) => sum + f.functionCount, 0); const totalExports = analysis.reduce((sum, f) => sum + f.exportCount, 0); const totalApiEndpoints = analysis.reduce((sum, f) => sum + f.apiEndpointCount, 0); // Calculate coverage percentage const fileCoverage = totalFiles > 0 ? ((filesWithTests / totalFiles) * 100).toFixed(1) : 0; const criticalCoverage = criticalFiles.length > 0 ? ((criticalWithTests / criticalFiles.length) * 100).toFixed(1) : 0; // Print summary console.log('\nüìä COVERAGE SUMMARY'); console.log('-'.repeat(40)); console.log(`Total Source Files: ${totalFiles}`); console.log(`Files with Tests: ${filesWithTests}`); console.log(`File Coverage: ${fileCoverage}%`); console.log(`\nCritical Files: ${criticalFiles.length}`); console.log(`Critical Files with Tests: ${criticalWithTests}`); console.log(`Critical Coverage: ${criticalCoverage}%`); console.log(`\nTotal Functions: ${totalFunctions}`); console.log(`Total Exports: ${totalExports}`); console.log(`Total API Endpoints: ${totalApiEndpoints}`); // List files without tests const filesWithoutTests = analysis.filter(f => !f.hasTest && f.functionCount > 3); if (filesWithoutTests.length > 0) { console.log('\n‚ö†Ô∏è FILES WITHOUT TESTS (sorted by complexity)'); console.log('-'.repeat(40)); filesWithoutTests .sort((a, b) => b.functionCount - a.functionCount) .slice(0, 20) .forEach(f => { const critical = f.isCritical ? ' [CRITICAL]' : ''; console.log(` - ${f.path} (${f.functionCount} functions)${critical}`); }); } // List critical files without tests const criticalWithoutTests = criticalFiles.filter(f => !f.hasTest); if (criticalWithoutTests.length > 0) { console.log('\nüö® CRITICAL FILES WITHOUT TESTS'); console.log('-'.repeat(40)); criticalWithoutTests.forEach(f => { console.log(` - ${f.path}`); }); } // Generate recommendations console.log('\nüìù RECOMMENDATIONS'); console.log('-'.repeat(40)); if (fileCoverage < 80) { console.log(` - Increase file coverage from ${fileCoverage}% to 80%+`); } if (criticalCoverage < 100) { console.log(` - Add tests for all critical files (${criticalWithTests}/${criticalFiles.length})`); } if (totalApiEndpoints > 0) { console.log(` - Add API integration tests for ${totalApiEndpoints} endpoints`); } // Write JSON report const reportPath = path.join(ROOT, 'test-coverage-report.json'); const report = { timestamp: new Date().toISOString(), summary: { totalFiles, filesWithTests, fileCoverage: parseFloat(fileCoverage), criticalFiles: criticalFiles.length, criticalWithTests, criticalCoverage: parseFloat(criticalCoverage), totalFunctions, totalExports, totalApiEndpoints, }, files: analysis, recommendations: [], }; fs.writeFileSync(reportPath, JSON.stringify(report, null, 2)); console.log(`\nüìÑ Report saved to: ${reportPath}`); // Return exit code based on coverage const targetCoverage = 80; const meetsTarget = parseFloat(fileCoverage) >= targetCoverage; if (!meetsTarget) { console.log(`\n‚ùå Coverage target not met: ${fileCoverage}% < ${targetCoverage}%`); } else { console.log(`\n‚úÖ Coverage target met: ${fileCoverage}% >= ${targetCoverage}%`); } return meetsTarget ? 0 : 1; } // Run the analysis try { const exitCode = generateReport(); process.exit(exitCode); } catch (error) { console.error('Error generating coverage report:', error); process.exit(1); }