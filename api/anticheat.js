/**
 * Anti-Cheat API
 * 
 * Provides endpoints for cheat reporting, score validation,
 * enforcement actions, and ban management.
 * 
 * @module api/anticheat
 */

const express = require('express');
const router = express.Router();

// Import services
const CheatDetectionService = require('../services/cheatDetectionService');
const EnforcementService = require('../services/enforcementService');

const cheatDetection = CheatDetectionService.getInstance();
const enforcement = EnforcementService.getInstance();

// Import database
const db = require('../models/database');

/**
 * Middleware to check admin access
 */
function requireAdmin(req, res, next) {
    const isAdmin = req.headers['x-admin-key'] === process.env.ADMIN_KEY;
    if (!isAdmin) {
        return res.status(403).json({
            success: false,
            error: 'Admin access required'
        });
    }
    next();
}

/**
 * POST /api/v1/anticheat/report
 * Submit a cheat report (automatic or manual)
 */
router.post('/report', async (req, res) => {
    try {
        const {
            userId,
            gameId,
            reportType,
            sessionId,
            evidence,
            autoGenerated = false
        } = req.body;

        if (!userId || !gameId || !reportType) {
            return res.status(400).json({
                success: false,
                error: 'userId, gameId, and reportType required'
            });
        }

        // Analyze session if provided
        let analysisResult = null;
        if (evidence?.sessionData) {
            analysisResult = cheatDetection.analyzeSession({
                id: sessionId,
                userId,
                gameId,
                ...evidence.sessionData
            });
        }

        // Determine severity
        const severity = analysisResult?.detections?.[0]?.severity ||
                        CheatDetectionService.VIOLATION_SEVERITY[reportType] ||
                        'medium';

        // Create report
        const report = {
            id: _generateId(),
            userId,
            gameId,
            reportType,
            severity,
            evidence: evidence || {},
            status: 'pending',
            autoGenerated,
            analysisResult,
            createdAt: Date.now()
        };

        // Store in database
        await db.create('cheat_reports', report);

        // Process for enforcement if auto-generated with high confidence
        let enforcementResult = null;
        if (autoGenerated && analysisResult?.overallProbability > 0.9) {
            enforcementResult = await enforcement.processViolation({
                userId,
                gameId,
                reportType,
                severity,
                evidence
            });
        }

        res.status(201).json({
            success: true,
            report: {
                id: report.id,
                status: report.status,
                enforcement: enforcementResult
            }
        });
    } catch (error) {
        console.error('Report API error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to submit report'
        });
    }
});

/**
 * GET /api/v1/anticheat/reports
 * List cheat reports (admin)
 */
router.get('/reports', requireAdmin, async (req, res) => {
    try {
        const { status, severity, userId, limit = 50, offset = 0 } = req.query;

        let reports = db.find('cheat_reports', {}) || [];

        // Apply filters
        if (status) {
            reports = reports.filter(r => r.status === status);
        }
        if (severity) {
            reports = reports.filter(r => r.severity === severity);
        }
        if (userId) {
            reports = reports.filter(r => r.userId === userId);
        }

        // Sort by created date (newest first)
        reports.sort((a, b) => b.createdAt - a.createdAt);

        // Apply pagination
        const total = reports.length;
        reports = reports.slice(parseInt(offset), parseInt(offset) + parseInt(limit));

        res.json({
            success: true,
            reports,
            pagination: {
                total,
                limit: parseInt(limit),
                offset: parseInt(offset)
            }
        });
    } catch (error) {
        console.error('List reports API error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to list reports'
        });
    }
});

/**
 * GET /api/v1/anticheat/reports/:id
 * Get report details (admin)
 */
router.get('/reports/:id', requireAdmin, async (req, res) => {
    try {
        const { id } = req.params;

        const report = db.findOne('cheat_reports', { id });
        if (!report) {
            return res.status(404).json({
                success: false,
                error: 'Report not found'
            });
        }

        res.json({
            success: true,
            report
        });
    } catch (error) {
        console.error('Get report API error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to get report'
        });
    }
});

/**
 * PUT /api/v1/anticheat/reports/:id/review
 * Review a report (admin)
 */
router.put('/reports/:id/review', requireAdmin, async (req, res) => {
    try {
        const { id } = req.params;
        const { decision, notes, reviewedBy } = req.body;

        if (!decision || !reviewedBy) {
            return res.status(400).json({
                success: false,
                error: 'decision and reviewedBy required'
            });
        }

        const report = db.findOne('cheat_reports', { id });
        if (!report) {
            return res.status(404).json({
                success: false,
                error: 'Report not found'
            });
        }

        // Update report
        report.status = decision === 'dismissed' ? 'dismissed' : 'reviewed';
        report.reviewedBy = reviewedBy;
        report.reviewedAt = Date.now();
        report.decision = decision;
        report.notes = notes;

        await db.update('cheat_reports', id, report);

        // If upheld, process enforcement
        let enforcementResult = null;
        if (decision === 'upheld' || decision === 'escalated') {
            enforcementResult = await enforcement.processViolation({
                userId: report.userId,
                gameId: report.gameId,
                reportType: report.reportType,
                severity: decision === 'escalated' ? 'critical' : report.severity,
                evidence: report.evidence
            });
        }

        res.json({
            success: true,
            report,
            enforcement: enforcementResult
        });
    } catch (error) {
        console.error('Review report API error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to review report'
        });
    }
});

/**
 * POST /api/v1/anticheat/validate-score
 * Validate a score submission
 */
router.post('/validate-score', async (req, res) => {
    try {
        const { userId, gameId, score, sessionData } = req.body;

        if (!userId || !gameId || score === undefined) {
            return res.status(400).json({
                success: false,
                error: 'userId, gameId, and score required'
            });
        }

        // Validate score
        const validation = cheatDetection.validateScore({
            userId,
            gameId,
            score,
            sessionData
        });

        if (!validation.valid) {
            // Create report for invalid score
            await db.create('cheat_reports', {
                id: _generateId(),
                userId,
                gameId,
                reportType: 'stat_manipulation',
                severity: 'high',
                evidence: { score, validation },
                status: 'pending',
                autoGenerated: true,
                createdAt: Date.now()
            });
        }

        res.json({
            success: true,
            valid: validation.valid,
            reason: validation.reason,
            ...(validation.valid ? {} : {
                probability: validation.probability,
                detections: validation.detections
            })
        });
    } catch (error) {
        console.error('Validate score API error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to validate score'
        });
    }
});

/**
 * POST /api/v1/anticheat/enforce
 * Apply enforcement action (admin)
 */
router.post('/enforce', requireAdmin, async (req, res) => {
    try {
        const { userId, actionType, reason, duration } = req.body;
        const adminId = req.headers['x-admin-id'];

        if (!userId || !actionType) {
            return res.status(400).json({
                success: false,
                error: 'userId and actionType required'
            });
        }

        const result = await enforcement.manualEnforcement(userId, {
            actionType,
            reason: reason || 'Manual enforcement',
            duration,
            adminId
        });

        res.json({
            success: true,
            enforcement: result
        });
    } catch (error) {
        console.error('Enforce API error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to apply enforcement'
        });
    }
});

/**
 * GET /api/v1/anticheat/user/:userId/history
 * Get user's cheat/enforcement history (admin)
 */
router.get('/user/:userId/history', requireAdmin, async (req, res) => {
    try {
        const { userId } = req.params;

        // Get violations
        const violations = enforcement.getRecentViolations(userId);

        // Get ban status
        const banStatus = enforcement.checkBanStatus(userId);

        // Get reports
        const reports = (db.find('cheat_reports', { userId }) || [])
            .sort((a, b) => b.createdAt - a.createdAt)
            .slice(0, 50);

        res.json({
            success: true,
            userId,
            history: {
                violations,
                reports,
                banStatus,
                violationCount: enforcement.getViolationCount(userId)
            }
        });
    } catch (error) {
        console.error('User history API error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to get user history'
        });
    }
});

/**
 * GET /api/v1/anticheat/user/:userId/ban-status
 * Check user's ban status
 */
router.get('/user/:userId/ban-status', async (req, res) => {
    try {
        const { userId } = req.params;

        const banStatus = enforcement.checkBanStatus(userId);

        res.json({
            success: true,
            userId,
            banStatus
        });
    } catch (error) {
        console.error('Ban status API error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to get ban status'
        });
    }
});

/**
 * POST /api/v1/anticheat/appeal
 * Submit ban appeal
 */
router.post('/appeal', async (req, res) => {
    try {
        const { userId, reason } = req.body;

        if (!userId || !reason) {
            return res.status(400).json({
                success: false,
                error: 'userId and reason required'
            });
        }

        const result = enforcement.submitAppeal(userId, reason);

        if (!result.success) {
            return res.status(400).json(result);
        }

        res.json({
            success: true,
            appeal: result.appeal,
            message: 'Appeal submitted successfully'
        });
    } catch (error) {
        console.error('Appeal API error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to submit appeal'
        });
    }
});

/**
 * GET /api/v1/anticheat/stats
 * Get anti-cheat statistics (admin)
 */
router.get('/stats', requireAdmin, async (req, res) => {
    try {
        const cheatStats = cheatDetection.getStats();
        const enforcementStats = enforcement.getStats();

        res.json({
            success: true,
            stats: {
                detection: cheatStats,
                enforcement: enforcementStats
            }
        });
    } catch (error) {
        console.error('Stats API error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to get stats'
        });
    }
});

/**
 * POST /api/v1/anticheat/analyze-session
 * Analyze a game session for cheating (admin/auto)
 */
router.post('/analyze-session', async (req, res) => {
    try {
        const { sessionId, userId, gameId, sessionData } = req.body;

        if (!sessionId || !userId || !sessionData) {
            return res.status(400).json({
                success: false,
                error: 'sessionId, userId, and sessionData required'
            });
        }

        const analysis = cheatDetection.analyzeSession({
            id: sessionId,
            userId,
            gameId,
            ...sessionData
        });

        res.json({
            success: true,
            analysis
        });
    } catch (error) {
        console.error('Analyze session API error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to analyze session'
        });
    }
});

/**
 * Generate unique ID
 */
function _generateId() {
    return 'acr_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);
}

module.exports = router;
