// Caribbean Conquest - Ship Entity System // Handles ship rendering, physics, and sailing mechanics // Ship class definitions const SHIP_CLASSES = { sloop: { name: 'Sloop', hp: 1000, maxSpeed: 12, turnRate: 2.0, cannons: 8, crew: 20, cargo: 50, length: 20, width: 6, mastHeight: 15, hullColor: 0x8B4513, sailColor: 0xFFF8DC }, brig: { name: 'Brig', hp: 2000, maxSpeed: 10, turnRate: 1.5, cannons: 16, crew: 40, cargo: 100, length: 35, width: 10, mastHeight: 25, hullColor: 0x654321, sailColor: 0xFFFAF0 }, frigate: { name: 'Frigate', hp: 3500, maxSpeed: 9, turnRate: 1.0, cannons: 28, crew: 80, cargo: 200, length: 50, width: 14, mastHeight: 35, hullColor: 0x3d2817, sailColor: 0xFFFFFF }, manOWar: { name: 'Man of War', hp: 5000, maxSpeed: 7, turnRate: 0.6, cannons: 48, crew: 150, cargo: 300, length: 70, width: 20, mastHeight: 45, hullColor: 0x2a1a0a, sailColor: 0xFFFAFA } }; // Base Ship class class Ship { constructor(game, config = {}) { this.game = game; this.config = config; // Ship type this.type = config.type || 'sloop'; this.classData = SHIP_CLASSES[this.type]; // Physics this.position = config.position ? config.position.clone() : new THREE.Vector3(0, 0, 0); this.velocity = new THREE.Vector3(0, 0, 0); this.rotation = config.rotation || 0; // Yaw rotation in radians this.angularVelocity = 0; // Sailing physics this.currentSpeed = 0; this.targetSpeed = 0; this.rudderAngle = 0; this.sailAngle = 0; this.anchorDown = false; // Wind this.windFactor = 1.0; // Stats this.hp = this.classData.hp; this.maxHp = this.classData.hp; this.crew = this.classData.crew; this.maxCrew = this.classData.crew; this.cargo = 0; this.maxCargo = this.classData.cargo; // Cannons this.cannons = { left: { ready: true, reloadTime: 0, reloadDuration: 5 }, right: { ready: true, reloadTime: 0, reloadDuration: 5 } }; // 3D objects this.mesh = null; this.hull = null; this.masts = []; this.sails = []; this.cannonPorts = []; // Wake effect this.wakeParticles = null; } async init() { this.createShipModel(); this.game.renderer.add(this.mesh); return true; } createShipModel() { // Create ship group this.mesh = new THREE.Group(); this.mesh.name = 'ship_' + this.type; // Create hull this.createHull(); // Create masts and sails this.createMasts(); // Create deck details this.createDeck(); // Create cannons this.createCannons(); // Position the ship this.mesh.position.copy(this.position); this.mesh.rotation.y = this.rotation; } createHull() { const { length, width, hullColor } = this.classData; // Main hull shape using custom geometry const hullShape = new THREE.Shape(); // Hull cross-section (boat shape) hullShape.moveTo(-width/2, 0); hullShape.quadraticCurveTo(-width/2, -width/3, 0, -width/2.5); hullShape.quadraticCurveTo(width/2, -width/3, width/2, 0); hullShape.lineTo(width/3, width/4); hullShape.lineTo(-width/3, width/4); hullShape.closePath(); const extrudeSettings = { steps: 20, depth: length, bevelEnabled: true, bevelThickness: 0.5, bevelSize: 0.3, bevelSegments: 3 }; const hullGeometry = new THREE.ExtrudeGeometry(hullShape, extrudeSettings); const hullMaterial = new THREE.MeshStandardMaterial({ color: hullColor, roughness: 0.8, metalness: 0.1 }); this.hull = new THREE.Mesh(hullGeometry, hullMaterial); this.hull.rotation.x = -Math.PI / 2; this.hull.rotation.z = Math.PI / 2; this.hull.position.z = -length / 2; this.hull.castShadow = true; this.hull.receiveShadow = true; this.mesh.add(this.hull); // Deck const deckGeometry = new THREE.BoxGeometry(width * 0.8, 0.5, length * 0.9); const deckMaterial = new THREE.MeshStandardMaterial({ color: 0xDEB887, roughness: 0.9 }); const deck = new THREE.Mesh(deckGeometry, deckMaterial); deck.position.y = width / 4 + 0.25; deck.castShadow = true; deck.receiveShadow = true; this.mesh.add(deck); // Bow (front) const bowGeometry = new THREE.ConeGeometry(width / 2, length / 4, 8); const bowMaterial = new THREE.MeshStandardMaterial({ color: hullColor, roughness: 0.8 }); const bow = new THREE.Mesh(bowGeometry, bowMaterial); bow.rotation.x = Math.PI / 2; bow.position.z = length / 2 + length / 8; bow.position.y = width / 6; bow.castShadow = true; this.mesh.add(bow); // Stern (back) const sternGeometry = new THREE.BoxGeometry(width * 0.7, width / 2, length / 6); const stern = new THREE.Mesh(sternGeometry, hullMaterial); stern.position.z = -length / 2 - length / 12; stern.position.y = width / 4; stern.castShadow = true; this.mesh.add(stern); } createMasts() { const { length, mastHeight, sailColor } = this.classData; const mastPositions = this.type === 'sloop' ? [0.3] : this.type === 'brig' ? [0.2, 0.6] : [0.15, 0.45, 0.75]; mastPositions.forEach((pos, index) => { // Mast const mastGeometry = new THREE.CylinderGeometry(0.3, 0.5, mastHeight, 8); const mastMaterial = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.9 }); const mast = new THREE.Mesh(mastGeometry, mastMaterial); mast.position.z = length * (pos - 0.5); mast.position.y = mastHeight / 2 + this.classData.width / 4; mast.castShadow = true; this.mesh.add(mast); this.masts.push(mast); // Sail const sailGeometry = new THREE.PlaneGeometry(this.classData.width * 1.5, mastHeight * 0.6); const sailMaterial = new THREE.MeshStandardMaterial({ color: sailColor, side: THREE.DoubleSide, roughness: 0.7, transparent: true, opacity: 0.95 }); const sail = new THREE.Mesh(sailGeometry, sailMaterial); sail.position.copy(mast.position); sail.position.y = mastHeight * 0.5; sail.rotation.y = Math.PI / 2; this.mesh.add(sail); this.sails.push(sail); // Crow's nest on main mast if (index === 0) { const nestGeometry = new THREE.CylinderGeometry(1.5, 1.2, 1.5, 8); const nest = new THREE.Mesh(nestGeometry, mastMaterial); nest.position.copy(mast.position); nest.position.y = mastHeight - 1; this.mesh.add(nest); } }); } createDeck() { const { length, width } = this.classData; // Ship wheel const wheelGeometry = new THREE.TorusGeometry(1, 0.2, 8, 16); const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.8 }); const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial); wheel.position.set(0, width / 2 + 1, -length / 3); wheel.rotation.x = Math.PI / 4; this.mesh.add(wheel); // Railing const railMaterial = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.8 }); // Side railings for (let side of [-1, 1]) { const railGeometry = new THREE.BoxGeometry(0.2, 1.5, length * 0.8); const rail = new THREE.Mesh(railGeometry, railMaterial); rail.position.set(side * width * 0.4, width / 2 + 1, 0); this.mesh.add(rail); } // Bowsprit const bowspritGeometry = new THREE.CylinderGeometry(0.3, 0.4, length / 3, 8); const bowsprit = new THREE.Mesh(bowspritGeometry, railMaterial); bowsprit.rotation.x = Math.PI / 2 - 0.3; bowsprit.position.set(0, width / 3, length / 2 + length / 6); this.mesh.add(bowsprit); } createCannons() { const { length, width, cannons } = this.classData; const cannonsPerSide = Math.floor(cannons / 2); const spacing = length * 0.6 / cannonsPerSide; for (let i = 0; i < cannonsPerSide; i++) { for (let side of [-1, 1]) { const cannonGroup = new THREE.Group(); // Cannon barrel const barrelGeometry = new THREE.CylinderGeometry(0.3, 0.4, 3, 8); const barrelMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8, roughness: 0.3 }); const barrel = new THREE.Mesh(barrelGeometry, barrelMaterial); barrel.rotation.x = Math.PI / 2; barrel.position.z = 1.5; cannonGroup.add(barrel); // Cannon base const baseGeometry = new THREE.BoxGeometry(1.5, 0.8, 2); const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.8 }); const base = new THREE.Mesh(baseGeometry, baseMaterial); base.position.y = -0.4; cannonGroup.add(base); // Position cannon cannonGroup.position.set( side * width * 0.35, this.classData.width / 2 + 0.5, -length * 0.3 + i * spacing ); cannonGroup.rotation.y = side * Math.PI / 2; this.mesh.add(cannonGroup); this.cannonPorts.push({ mesh: cannonGroup, side: side === -1 ? 'left' : 'right', index: i, ready: true }); } } } update(dt) { // Update sailing physics this.updateSailing(dt); // Update position on waves this.updateBuoyancy(); // Update wake effect this.updateWake(); // Update cannon reloads this.updateCannons(dt); } updateSailing(dt) { if (this.anchorDown) { this.currentSpeed *= 0.95; return; } // Get wind direction and speed const wind = this.game.weather?.wind || { direction: new THREE.Vector2(1, 0), speed: 10 }; // Calculate wind factor based on sail angle relative to wind const shipDir = new THREE.Vector2( Math.sin(this.rotation), Math.cos(this.rotation) ); const windAngle = Math.abs(Math.acos( shipDir.dot(wind.direction.normalize()) )); // Best sailing is perpendicular to wind (beam reach) // Worst is directly into wind (in irons) this.windFactor = Math.max(0.1, Math.sin(windAngle)); // Apply rudder turning if (Math.abs(this.rudderAngle) > 0.01) { const turnRate = this.classData.turnRate * this.rudderAngle; const speedFactor = Math.min(this.currentSpeed / this.classData.maxSpeed, 1); this.rotation += turnRate * speedFactor * dt; } // Calculate target speed based on wind and sails const windSpeedFactor = wind.speed / 15; // Normalize wind speed this.targetSpeed = this.classData.maxSpeed * this.windFactor * windSpeedFactor; // Smoothly adjust current speed const acceleration = 2.0 * dt; if (this.currentSpeed < this.targetSpeed) { this.currentSpeed = Math.min(this.currentSpeed + acceleration, this.targetSpeed); } else { this.currentSpeed = Math.max(this.currentSpeed - acceleration * 0.5, this.targetSpeed); } // Update velocity const direction = new THREE.Vector3( Math.sin(this.rotation), 0, Math.cos(this.rotation) ); this.velocity.copy(direction).multiplyScalar(this.currentSpeed); // Update position this.position.add(this.velocity.clone().multiplyScalar(dt)); // Update mesh position this.mesh.position.copy(this.position); this.mesh.rotation.y = this.rotation; } updateBuoyancy() { // Get wave height at ship position const waveHeight = this.game.ocean?.getWaveHeight( this.position.x, this.position.z, this.game.gameTime ) || 0; // Smoothly adjust Y position const targetY = waveHeight; this.mesh.position.y += (targetY - this.mesh.position.y) * 0.1; // Add slight roll and pitch based on waves const roll = Math.sin(this.game.gameTime * 0.5) * 0.02; const pitch = Math.cos(this.game.gameTime * 0.7) * 0.01; this.mesh.rotation.z = roll; this.mesh.rotation.x = pitch; } updateWake() { // TODO: Implement wake particle system } updateCannons(dt) { for (const side of ['left', 'right']) { const cannon = this.cannons[side]; if (!cannon.ready) { cannon.reloadTime -= dt; if (cannon.reloadTime <= 0) { cannon.ready = true; cannon.reloadTime = 0; } } } } fireCannons(side) { const cannon = this.cannons[side]; if (!cannon.ready) return false; // Create projectile for each cannon const cannonPorts = this.cannonPorts.filter(p => p.side === side); for (const port of cannonPorts) { this.createCannonball(port); } // Start reload cannon.ready = false; cannon.reloadTime = cannon.reloadDuration; return true; } createCannonball(port) { const worldPos = new THREE.Vector3(); port.mesh.getWorldPosition(worldPos); const direction = new THREE.Vector3( Math.sin(this.rotation + (port.side === 'left' ? -Math.PI/2 : Math.PI/2)), 0, Math.cos(this.rotation + (port.side === 'left' ? -Math.PI/2 : Math.PI/2)) ); const projectile = { position: worldPos, velocity: direction.multiplyScalar(200), type: 'cannonball', damage: 50, owner: this, lifetime: 3 }; this.game.projectiles.push(projectile); // Create visual const geometry = new THREE.SphereGeometry(0.5, 8, 8); const material = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 }); const mesh = new THREE.Mesh(geometry, material); mesh.position.copy(worldPos); this.game.renderer.add(mesh); projectile.mesh = mesh; } takeDamage(amount) { this.hp = Math.max(0, this.hp - amount); if (this.hp <= 0) { this.sink(); } } sink() { // Remove from scene this.game.renderer.remove(this.mesh); // Remove from ships array const index = this.game.ships.indexOf(this); if (index > -1) { this.game.ships.splice(index, 1); } } } // Player Ship class PlayerShip extends Ship { constructor(game, config = {}) { super(game, { type: 'frigate', ...config }); this.isPlayer = true; } async init() { await super.init(); // Create player-specific features this.createFlag(); return true; } createFlag() { // Create pirate flag const flagGeometry = new THREE.PlaneGeometry(4, 2.5); const flagMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide }); const flag = new THREE.Mesh(flagGeometry, flagMaterial); flag.position.set(0, this.classData.mastHeight + 2, -this.classData.length / 3); this.mesh.add(flag); } update(dt) { super.update(dt); // Update HUD with ship stats this.updateHUD(); } updateHUD() { const hullBar = document.getElementById('hull-bar'); const sailBar = document.getElementById('sail-bar'); const crewBar = document.getElementById('crew-bar'); const speedDisplay = document.getElementById('ship-speed'); if (hullBar) hullBar.style.width = (this.hp / this.maxHp * 100) + '%'; if (sailBar) sailBar.style.width = (this.windFactor * 100) + '%'; if (crewBar) crewBar.style.width = (this.crew / this.maxCrew * 100) + '%'; if (speedDisplay) speedDisplay.textContent = this.currentSpeed.toFixed(1); } } // NPC Ship class NPCShip extends Ship { constructor(game, config = {}) { super(game, config); this.faction = config.faction || 'pirate'; this.aiState = 'idle'; this.target = null; this.patrolPoints = []; this.currentPatrolIndex = 0; } async init() { await super.init(); // Set faction colors this.setFactionColors(); return true; } setFactionColors() { const factionColors = { british: 0xCC0000, spanish: 0xFFCC00, french: 0x0066CC, dutch: 0xFF6600, pirate: 0x000000 }; // Update flag color const flag = this.mesh.children.find(c => c.geometry?.type === 'PlaneGeometry' && c.material?.color); if (flag && factionColors[this.faction]) { flag.material.color.setHex(factionColors[this.faction]); } } update(dt) { super.update(dt); // AI behavior is handled by AISystem } } // Export for use if (typeof module !== 'undefined' && module.exports) { module.exports = { Ship, PlayerShip, NPCShip, SHIP_CLASSES }; }