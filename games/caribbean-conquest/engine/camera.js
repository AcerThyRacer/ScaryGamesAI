// Caribbean Conquest - Camera Controller // Third-person cinematic camera with smooth following class CameraController { constructor(game) { this.game = game; this.camera = null; // Camera modes this.mode = 'follow'; // 'follow', 'free', 'cinematic' // Follow camera settings this.followDistance = 80; this.followHeight = 30; this.followSpeed = 3; this.rotationSpeed = 2; // Current state this.currentPosition = new THREE.Vector3(0, 50, 100); this.currentLookAt = new THREE.Vector3(0, 0, 0); this.targetPosition = new THREE.Vector3(); this.targetLookAt = new THREE.Vector3(); // Camera shake this.shakeIntensity = 0; this.shakeDuration = 0; // Free camera (for debugging) this.freeCameraSpeed = 50; this.freeCameraRotation = { x: 0, y: 0 }; } async init() { // Create camera this.camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 0.1, 20000 ); this.camera.position.copy(this.currentPosition); // Set as main camera this.game.renderer.setCamera(this.camera); return true; } update(dt) { switch (this.mode) { case 'follow': this.updateFollowCamera(dt); break; case 'free': this.updateFreeCamera(dt); break; case 'cinematic': this.updateCinematicCamera(dt); break; } // Apply camera shake if (this.shakeDuration > 0) { this.applyShake(dt); } } updateFollowCamera(dt) { const player = this.game.player; if (!player || !player.mesh) return; // Get player position and rotation const playerPos = player.mesh.position; const playerRot = player.rotation; // Calculate target camera position (behind and above the ship) const offsetX = Math.sin(playerRot) * this.followDistance; const offsetZ = Math.cos(playerRot) * this.followDistance; this.targetPosition.set( playerPos.x - offsetX, playerPos.y + this.followHeight, playerPos.z - offsetZ ); // Calculate look-at position (slightly ahead of ship) const lookAhead = 20; this.targetLookAt.set( playerPos.x + Math.sin(playerRot) * lookAhead, playerPos.y + 5, playerPos.z + Math.cos(playerRot) * lookAhead ); // Smoothly interpolate camera position const followLerp = 1 - Math.pow(0.001, dt); this.currentPosition.lerp(this.targetPosition, followLerp); this.currentLookAt.lerp(this.targetLookAt, followLerp); // Apply to camera this.camera.position.copy(this.currentPosition); this.camera.lookAt(this.currentLookAt); } updateFreeCamera(dt) { // Free camera controlled by input // Handled by InputSystem } updateCinematicCamera(dt) { // Cinematic camera for events, cutscenes, etc. // TODO: Implement cinematic camera paths } applyShake(dt) { this.shakeDuration -= dt; const intensity = this.shakeIntensity * (this.shakeDuration / this.shakeDuration); const shake = new THREE.Vector3( (Math.random() - 0.5) * intensity, (Math.random() - 0.5) * intensity, (Math.random() - 0.5) * intensity ); this.camera.position.add(shake); } shake(intensity = 1, duration = 0.5) { this.shakeIntensity = intensity; this.shakeDuration = duration; } setMode(mode) { this.mode = mode; if (mode === 'free') { // Enable pointer lock for free camera // this.game.input.requestPointerLock(); } } // Zoom in/out zoom(delta) { this.followDistance = Math.max(30, Math.min(150, this.followDistance + delta * 10)); this.followHeight = Math.max(15, Math.min(60, this.followHeight + delta * 5)); } }