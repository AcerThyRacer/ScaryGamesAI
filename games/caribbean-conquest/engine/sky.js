// Caribbean Conquest - Dynamic Sky System // Procedural sky with day/night cycle, clouds, and stars class Sky { constructor(game) { this.game = game; this.mesh = null; this.geometry = null; this.material = null; // Sky parameters this.radius = 5000; this.dayDuration = 24 * 60; // 24 minutes = 1 day this.timeOfDay = 6 * 60; // Start at 6:00 AM // Colors this.dayColors = { zenith: new THREE.Color(0x0077be), horizon: new THREE.Color(0x87ceeb), sun: new THREE.Color(0xffffee) }; this.sunsetColors = { zenith: new THREE.Color(0x1a0a2e), horizon: new THREE.Color(0xff6b35), sun: new THREE.Color(0xff4500) }; this.nightColors = { zenith: new THREE.Color(0x000011), horizon: new THREE.Color(0x001133), sun: new THREE.Color(0x4466aa) }; // Clouds this.clouds = []; this.cloudParticles = null; } async init() { // Create sky dome this.geometry = new THREE.SphereGeometry(this.radius, 32, 32); // Invert normals so we see the inside this.geometry.scale(-1, 1, 1); // Create sky shader material this.material = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0 }, uSunPosition: { value: new THREE.Vector3(0, 1, 0) }, uDayZenith: { value: this.dayColors.zenith }, uDayHorizon: { value: this.dayColors.horizon }, uSunsetColor: { value: this.sunsetColors.horizon }, uNightZenith: { value: this.nightColors.zenith }, uNightHorizon: { value: this.nightColors.horizon } }, vertexShader: this.getVertexShader(), fragmentShader: this.getFragmentShader(), side: THREE.BackSide, depthWrite: false }); this.mesh = new THREE.Mesh(this.geometry, this.material); this.mesh.name = 'sky'; this.game.renderer.add(this.mesh); // Create sun this.createSun(); // Create stars this.createStars(); // Create clouds this.createClouds(); return true; } getVertexShader() { return ` varying vec3 vWorldPosition; varying vec2 vUv; void main() { vUv = uv; vec4 worldPos = modelMatrix * vec4(position, 1.0); vWorldPosition = worldPos.xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } `; } getFragmentShader() { return ` uniform float uTime; uniform vec3 uSunPosition; uniform vec3 uDayZenith; uniform vec3 uDayHorizon; uniform vec3 uSunsetColor; uniform vec3 uNightZenith; uniform vec3 uNightHorizon; varying vec3 vWorldPosition; varying vec2 vUv; void main() { // Calculate view direction vec3 viewDir = normalize(vWorldPosition); float height = viewDir.y; // Day/night factor based on sun position float sunHeight = uSunPosition.y; float dayFactor = smoothstep(-0.2, 0.3, sunHeight); float sunsetFactor = 1.0 - abs(sunHeight); sunsetFactor = pow(sunsetFactor, 3.0); // Gradient based on height (horizon to zenith) float gradientFactor = pow(1.0 - max(height, 0.0), 3.0); // Day sky color vec3 dayColor = mix(uDayZenith, uDayHorizon, gradientFactor); // Night sky color vec3 nightColor = mix(uNightZenith, uNightHorizon, gradientFactor); // Blend day and night vec3 skyColor = mix(nightColor, dayColor, dayFactor); // Add sunset colors near horizon if (height < 0.3 && sunHeight < 0.3) { float sunsetBlend = (1.0 - height / 0.3) * sunsetFactor; skyColor = mix(skyColor, uSunsetColor, sunsetBlend * 0.7); } // Add sun glow float sunDist = distance(viewDir, normalize(uSunPosition)); float sunGlow = exp(-sunDist * 3.0) * dayFactor; skyColor += vec3(1.0, 0.9, 0.7) * sunGlow * 0.5; gl_FragColor = vec4(skyColor, 1.0); } `; } createSun() { // Create sun as a bright disc const sunGeometry = new THREE.CircleGeometry(100, 32); const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffffee, side: THREE.DoubleSide, transparent: true, opacity: 1 }); this.sun = new THREE.Mesh(sunGeometry, sunMaterial); this.sun.position.set(0, this.radius * 0.9, -this.radius * 0.8); this.sun.lookAt(0, 0, 0); this.sun.name = 'sun'; this.game.renderer.add(this.sun); // Sun glow const glowGeometry = new THREE.CircleGeometry(200, 32); const glowMaterial = new THREE.ShaderMaterial({ uniforms: { uColor: { value: new THREE.Color(0xffaa44) } }, vertexShader: ` varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } `, fragmentShader: ` uniform vec3 uColor; varying vec2 vUv; void main() { float dist = distance(vUv, vec2(0.5)); float alpha = smoothstep(0.5, 0.0, dist) * 0.5; gl_FragColor = vec4(uColor, alpha); } `, transparent: true, side: THREE.DoubleSide, depthWrite: false }); this.sunGlow = new THREE.Mesh(glowGeometry, glowMaterial); this.sunGlow.position.copy(this.sun.position); this.sunGlow.position.z += 10; this.sunGlow.lookAt(0, 0, 0); this.game.renderer.add(this.sunGlow); } createStars() { // Create star field const starCount = 2000; const positions = new Float32Array(starCount * 3); const sizes = new Float32Array(starCount); for (let i = 0; i < starCount; i++) { // Random position on sphere const theta = Math.random() * Math.PI * 2; const phi = Math.acos(Math.random() * 2 - 1); const r = this.radius * 0.95; positions[i * 3] = r * Math.sin(phi) * Math.cos(theta); positions[i * 3 + 1] = r * Math.cos(phi); positions[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta); sizes[i] = Math.random() * 2 + 0.5; } const starGeometry = new THREE.BufferGeometry(); starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1)); const starMaterial = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0 }, uSunHeight: { value: 0 } }, vertexShader: ` attribute float size; varying float vSize; void main() { vSize = size; vec4 mvPosition = modelViewMatrix * vec4(position, 1.0); gl_PointSize = size * (300.0 / -mvPosition.z); gl_Position = projectionMatrix * mvPosition; } `, fragmentShader: ` uniform float uSunHeight; varying float vSize; void main() { float dist = distance(gl_PointCoord, vec2(0.5)); if (dist > 0.5) discard; float alpha = (1.0 - dist * 2.0) * smoothstep(-0.1, -0.3, uSunHeight); gl_FragColor = vec4(1.0, 1.0, 0.95, alpha); } `, transparent: true, depthWrite: false }); this.stars = new THREE.Points(starGeometry, starMaterial); this.stars.name = 'stars'; this.game.renderer.add(this.stars); } createClouds() { // Create procedural cloud layer const cloudGeometry = new THREE.PlaneGeometry(this.radius * 2, this.radius * 2, 1, 1); const cloudMaterial = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0 }, uSunPosition: { value: new THREE.Vector3(0, 1, 0) } }, vertexShader: ` varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); } `, fragmentShader: ` uniform float uTime; uniform vec3 uSunPosition; varying vec2 vUv; // Simplex noise function vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; } vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); } float snoise(vec2 v) { const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439); vec2 i = floor(v + dot(v, C.yy)); vec2 x0 = v - i + dot(i, C.xx); vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0); vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1; i = mod289(i); vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0)); vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0); m = m*m; m = m*m; vec3 x = 2.0 * fract(p * C.www) - 1.0; vec3 h = abs(x) - 0.5; vec3 ox = floor(x + 0.5); vec3 a0 = x - ox; m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h); vec3 g; g.x = a0.x * x0.x + h.x * x0.y; g.yz = a0.yz * x12.xz + h.yz * x12.yw; return 130.0 * dot(m, g); } void main() { vec2 uv = vUv * 3.0; float time = uTime * 0.01; // Layered noise for clouds float noise1 = snoise(uv * 2.0 + time * 0.5); float noise2 = snoise(uv * 4.0 - time * 0.3) * 0.5; float noise3 = snoise(uv * 8.0 + time * 0.2) * 0.25; float clouds = (noise1 + noise2 + noise3) * 0.5 + 0.5; clouds = smoothstep(0.4, 0.8, clouds); // Day/night factor float dayFactor = smoothstep(-0.1, 0.2, uSunPosition.y); // Cloud color vec3 dayCloud = vec3(1.0, 1.0, 1.0); vec3 nightCloud = vec3(0.2, 0.2, 0.3); vec3 sunsetCloud = vec3(1.0, 0.6, 0.4); vec3 cloudColor = mix(nightCloud, dayCloud, dayFactor); // Sunset tint float sunsetFactor = 1.0 - abs(uSunPosition.y); sunsetFactor = pow(sunsetFactor, 2.0); cloudColor = mix(cloudColor, sunsetCloud, sunsetFactor * 0.5); float alpha = clouds * 0.6 * smoothstep(0.0, 0.3, vUv.y) * smoothstep(1.0, 0.7, vUv.y); gl_FragColor = vec4(cloudColor, alpha); } `, transparent: true, side: THREE.DoubleSide, depthWrite: false }); this.cloudLayer = new THREE.Mesh(cloudGeometry, cloudMaterial); this.cloudLayer.rotation.x = -Math.PI / 2; this.cloudLayer.position.y = 800; this.cloudLayer.name = 'clouds'; this.game.renderer.add(this.cloudLayer); } update(dt, gameTime) { // Update time of day this.timeOfDay += dt; if (this.timeOfDay >= this.dayDuration) { this.timeOfDay -= this.dayDuration; } // Calculate sun position const dayProgress = this.timeOfDay / this.dayDuration; const sunAngle = dayProgress * Math.PI * 2 - Math.PI / 2; const sunX = Math.cos(sunAngle) * this.radius * 0.9; const sunY = Math.sin(sunAngle) * this.radius * 0.9; const sunZ = -this.radius * 0.8; // Update sun position this.sun.position.set(sunX, sunY, sunZ); this.sun.lookAt(0, 0, 0); this.sunGlow.position.copy(this.sun.position); this.sunGlow.position.z += 10; this.sunGlow.lookAt(0, 0, 0); // Update sun visibility (hide at night) const sunVisible = sunY > -this.radius * 0.3; this.sun.visible = sunVisible; this.sunGlow.visible = sunVisible; // Update shader uniforms const sunDir = new THREE.Vector3(sunX, sunY, sunZ).normalize(); this.material.uniforms.uSunPosition.value.copy(sunDir); this.material.uniforms.uTime.value = gameTime; // Update stars this.stars.material.uniforms.uSunHeight.value = sunDir.y; this.stars.material.uniforms.uTime.value = gameTime; // Update clouds this.cloudLayer.material.uniforms.uSunPosition.value.copy(sunDir); this.cloudLayer.material.uniforms.uTime.value = gameTime; // Update renderer's sun light this.game.renderer.updateSunPosition(gameTime); } }