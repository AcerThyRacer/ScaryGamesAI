// Caribbean Conquest - Ocean Rendering System // Gerstner wave simulation with realistic water shaders class Ocean { constructor(game) { this.game = game; this.mesh = null; this.geometry = null; this.material = null; // Ocean parameters this.size = 10000; // Size of ocean plane this.segments = 256; // Vertex resolution this.waveHeight = 2.0; this.waveSpeed = 1.0; this.waterColor = new THREE.Color(0x0066aa); this.deepColor = new THREE.Color(0x001133); // Wave parameters (Gerstner waves) this.waves = [ { direction: new THREE.Vector2(1, 0), steepness: 0.15, wavelength: 60 }, { direction: new THREE.Vector2(1, 1).normalize(), steepness: 0.1, wavelength: 31 }, { direction: new THREE.Vector2(1, -0.5).normalize(), steepness: 0.08, wavelength: 20 }, { direction: new THREE.Vector2(-1, 0.3).normalize(), steepness: 0.05, wavelength: 15 } ]; } async init() { // Create ocean geometry this.geometry = new THREE.PlaneGeometry( this.size, this.size, this.segments, this.segments ); // Rotate to horizontal this.geometry.rotateX(-Math.PI / 2); // Create ocean shader material this.material = new THREE.ShaderMaterial({ uniforms: { uTime: { value: 0 }, uWaveHeight: { value: this.waveHeight }, uWaterColor: { value: this.waterColor }, uDeepColor: { value: this.deepColor }, uFoamColor: { value: new THREE.Color(0xffffff) }, uSunDirection: { value: new THREE.Vector3(0.5, 0.5, 0.5) }, uSunColor: { value: new THREE.Color(0xffffee) }, // Wave uniforms uWave1Dir: { value: this.waves[0].direction }, uWave1Steep: { value: this.waves[0].steepness }, uWave1Len: { value: this.waves[0].wavelength }, uWave2Dir: { value: this.waves[1].direction }, uWave2Steep: { value: this.waves[1].steepness }, uWave2Len: { value: this.waves[1].wavelength }, uWave3Dir: { value: this.waves[2].direction }, uWave3Steep: { value: this.waves[2].steepness }, uWave3Len: { value: this.waves[2].wavelength }, uWave4Dir: { value: this.waves[3].direction }, uWave4Steep: { value: this.waves[3].steepness }, uWave4Len: { value: this.waves[3].wavelength } }, vertexShader: this.getVertexShader(), fragmentShader: this.getFragmentShader(), transparent: true, side: THREE.DoubleSide, fog: true }); // Create mesh this.mesh = new THREE.Mesh(this.geometry, this.material); this.mesh.receiveShadow = true; this.mesh.name = 'ocean'; // Add to scene this.game.renderer.add(this.mesh); return true; } getVertexShader() { return ` uniform float uTime; uniform float uWaveHeight; // Wave uniforms uniform vec2 uWave1Dir; uniform float uWave1Steep; uniform float uWave1Len; uniform vec2 uWave2Dir; uniform float uWave2Steep; uniform float uWave2Len; uniform vec2 uWave3Dir; uniform float uWave3Steep; uniform float uWave3Len; uniform vec2 uWave4Dir; uniform float uWave4Steep; uniform float uWave4Len; varying vec3 vWorldPosition; varying vec3 vNormal; varying float vWaveHeight; // Gerstner wave function vec3 gerstnerWave(vec2 direction, float steepness, float wavelength, vec3 pos, float time) { float k = 2.0 * 3.14159 / wavelength; float c = sqrt(9.8 / k); vec2 d = normalize(direction); float f = k * (dot(d, pos.xz) - c * time); float a = steepness / k; return vec3( d.x * a * cos(f), a * sin(f), d.y * a * cos(f) ); } void main() { vec3 pos = position; float time = uTime * 0.5; // Apply Gerstner waves vec3 wave1 = gerstnerWave(uWave1Dir, uWave1Steep, uWave1Len, pos, time); vec3 wave2 = gerstnerWave(uWave2Dir, uWave2Steep, uWave2Len, pos, time * 1.1); vec3 wave3 = gerstnerWave(uWave3Dir, uWave3Steep, uWave3Len, pos, time * 0.9); vec3 wave4 = gerstnerWave(uWave4Dir, uWave4Steep, uWave4Len, pos, time * 1.2); pos += wave1 + wave2 + wave3 + wave4; vWaveHeight = pos.y; // Calculate normal for lighting vec3 tangent = normalize(vec3(1.0, 0.0, 0.0) + vec3( wave1.x * 0.1, wave1.y * 0.1, 0.0 )); vec3 bitangent = normalize(vec3(0.0, 0.0, 1.0) + vec3( 0.0, wave1.y * 0.1, wave1.z * 0.1 )); vNormal = normalize(cross(bitangent, tangent)); vWorldPosition = (modelMatrix * vec4(pos, 1.0)).xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0); } `; } getFragmentShader() { return ` uniform vec3 uWaterColor; uniform vec3 uDeepColor; uniform vec3 uFoamColor; uniform vec3 uSunDirection; uniform vec3 uSunColor; uniform float uTime; varying vec3 vWorldPosition; varying vec3 vNormal; varying float vWaveHeight; void main() { // Base water color with depth gradient vec3 color = mix(uDeepColor, uWaterColor, smoothstep(-2.0, 2.0, vWaveHeight)); // Fresnel effect for reflections vec3 viewDir = normalize(cameraPosition - vWorldPosition); float fresnel = pow(1.0 - max(dot(viewDir, vNormal), 0.0), 3.0); // Specular highlight from sun vec3 reflectDir = reflect(-uSunDirection, vNormal); float spec = pow(max(dot(viewDir, reflectDir), 0.0), 128.0); // Add foam on wave peaks float foam = smoothstep(1.5, 2.5, vWaveHeight); color = mix(color, uFoamColor, foam * 0.3); // Combine lighting color += uSunColor * spec * 0.5; color = mix(color, vec3(0.8, 0.9, 1.0), fresnel * 0.3); // Add subtle subsurface scattering float sss = max(dot(vNormal, uSunDirection), 0.0) * 0.2; color += vec3(0.0, 0.3, 0.2) * sss; gl_FragColor = vec4(color, 0.95); } `; } update(dt, gameTime) { // Update shader uniforms this.material.uniforms.uTime.value = gameTime; // Update sun direction based on renderer's sun position const sunPos = this.game.renderer.sunLight.position; this.material.uniforms.uSunDirection.value.copy(sunPos).normalize(); // Adjust wave height based on weather const weatherIntensity = this.game.weather?.stormIntensity || 0; this.material.uniforms.uWaveHeight.value = this.waveHeight * (1 + weatherIntensity * 2); } // Get wave height at a specific position getWaveHeight(x, z, time) { let height = 0; for (const wave of this.waves) { const k = (2 * Math.PI) / wave.wavelength; const c = Math.sqrt(9.8 / k); const d = wave.direction; const f = k * (d.x * x + d.y * z - c * time * 0.5); const a = wave.steepness / k; height += a * Math.sin(f); } return height; } }