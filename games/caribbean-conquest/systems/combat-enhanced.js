// Caribbean Conquest - Enhanced Combat System // Phase 2: Advanced naval combat with ammunition types, damage zones, and boarding class EnhancedCombatSystem { constructor(game) { this.game = game; // Ammunition types this.ammoTypes = null; this.loadAmmunitionTypes(); // Active projectiles this.projectiles = []; this.maxProjectiles = 500; // Damage zones this.damageZones = { hull: { multiplier: 1.0, effects: ['leak', 'fire'] }, sails: { multiplier: 0.3, effects: ['speed_reduction'] }, crew: { multiplier: 0.2, effects: ['morale_loss'] }, rudder: { multiplier: 0.5, effects: ['turn_reduction'] }, magazine: { multiplier: 3.0, effects: ['explosion'] } }; // Active effects this.activeFires = []; this.activeLeaks = []; // Boarding this.boardingActions = []; this.isBoarding = false; this.boardingTarget = null; // Combat stats this.stats = { shipsSunk: 0, damageDealt: 0, damageTaken: 0, boardingSuccess: 0, goldEarned: 0 }; } async loadAmmunitionTypes() { try { const response = await fetch('data/ammunition.json'); this.ammoTypes = await response.json(); } catch (e) { // Default ammunition types this.ammoTypes = { types: { round: { name: 'Round Shot', damage: 50, range: 400, accuracy: 0.8, hullDamage: 1.0, sailDamage: 0.3, crewDamage: 0.2, effect: 'impact' }, chain: { name: 'Chain Shot', damage: 30, range: 300, accuracy: 0.7, hullDamage: 0.2, sailDamage: 1.5, crewDamage: 0.1, effect: 'sail_tear' }, grape: { name: 'Grapeshot', damage: 20, range: 200, accuracy: 0.9, hullDamage: 0.1, sailDamage: 0.1, crewDamage: 2.0, effect: 'scatter' } } }; } } init() { // Initialize combat system } update(dt) { // Update all projectiles this.updateProjectiles(dt); // Update active effects this.updateEffects(dt); // Update boarding if active if (this.isBoarding) { this.updateBoarding(dt); } } // ============ PROJECTILE SYSTEM ============ fireCannons(ship, side, ammoType = 'round') { if (!ship.cannons[side].ready) return false; if (!ship.ammo || ship.ammo[ammoType] <= 0) { this.game.hud?.showNotification('Out of Ammo!', 'No ' + ammoType + ' remaining'); return false; } const ammoData = this.ammoTypes?.types[ammoType] || this.ammoTypes.types.round; // Consume ammunition if (ship.ammo) { ship.ammo[ammoType]--; } // Get cannon ports for this side const cannonPorts = ship.cannonPorts.filter(p => p.side === side); // Fire each cannon for (const port of cannonPorts) { // Add accuracy variance const accuracy = ammoData.accuracy + (Math.random() - 0.5) * 0.2; if (Math.random() > accuracy) continue; // Miss this cannon // Create projectile this.createProjectile(ship, port, ammoType, ammoData); } // Start reload const reloadTime = this.ammoTypes?.reloadTimes[ship.type] || 5; ship.cannons[side].ready = false; ship.cannons[side].reloadTime = reloadTime; // Camera shake this.game.camera?.shake(1.5, 0.2); return true; } createProjectile(ship, port, ammoType, ammoData) { const worldPos = new THREE.Vector3(); port.mesh.getWorldPosition(worldPos); // Calculate direction with spread const spread = (1 - ammoData.accuracy) * 0.2; const baseAngle = ship.rotation + (port.side === 'left' ? -Math.PI/2 : Math.PI/2); const angle = baseAngle + (Math.random() - 0.5) * spread; const elevation = 0.1 + Math.random() * 0.05; // Slight upward angle const direction = new THREE.Vector3( Math.sin(angle), elevation, Math.cos(angle) ).normalize(); const projectile = { id: Date.now() + Math.random(), position: worldPos.clone(), velocity: direction.multiplyScalar(ammoData.range * 0.5), type: ammoType, ammoData: ammoData, owner: ship, damage: ammoData.damage, lifetime: 5, mesh: null, trail: [] }; // Create visual mesh const geometry = this.getProjectileGeometry(ammoType); const material = this.getProjectileMaterial(ammoType); projectile.mesh = new THREE.Mesh(geometry, material); projectile.mesh.position.copy(worldPos); this.game.renderer.add(projectile.mesh); this.projectiles.push(projectile); return projectile; } getProjectileGeometry(ammoType) { switch (ammoType) { case 'chain': return new THREE.TorusGeometry(0.3, 0.1, 8, 16); case 'grape': return new THREE.SphereGeometry(0.2, 6, 6); case 'explosive': return new THREE.SphereGeometry(0.6, 8, 8); default: return new THREE.SphereGeometry(0.4, 8, 8); } } getProjectileMaterial(ammoType) { switch (ammoType) { case 'chain': return new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.9 }); case 'grape': return new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.7 }); case 'explosive': return new THREE.MeshStandardMaterial({ color: 0xff4400, emissive: 0xff2200, emissiveIntensity: 0.5 }); case 'heated': return new THREE.MeshStandardMaterial({ color: 0xff6600, emissive: 0xff4400, emissiveIntensity: 0.8 }); default: return new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.8 }); } } updateProjectiles(dt) { for (let i = this.projectiles.length - 1; i >= 0; i--) { const proj = this.projectiles[i]; // Update lifetime proj.lifetime -= dt; if (proj.lifetime <= 0) { this.removeProjectile(proj, i); continue; } // Apply gravity proj.velocity.y -= 9.8 * dt; // Update position proj.position.add(proj.velocity.clone().multiplyScalar(dt)); // Update mesh if (proj.mesh) { proj.mesh.position.copy(proj.position); proj.mesh.rotation.x += dt * 5; proj.mesh.rotation.z += dt * 3; } // Check collisions this.checkProjectileCollisions(proj, i); } } checkProjectileCollisions(proj, projIndex) { // Check collision with ships for (const ship of this.game.ships) { if (ship === proj.owner) continue; const hitZone = this.checkShipHit(proj, ship); if (hitZone) { this.onProjectileHit(proj, ship, hitZone, projIndex); return; } } // Check water collision if (proj.position.y < 0) { this.createWaterSplash(proj.position, proj.ammoData?.effect === 'explosive'); this.removeProjectile(proj, projIndex); } } checkShipHit(proj, ship) { if (!ship.mesh) return null; const shipPos = ship.mesh.position; const { length, width } = ship.classData; // Calculate relative position const relX = proj.position.x - shipPos.x; const relZ = proj.position.z - shipPos.z; const relY = proj.position.y - shipPos.y; // Rotate to ship's local space const cos = Math.cos(-ship.rotation); const sin = Math.sin(-ship.rotation); const localX = relX * cos - relZ * sin; const localZ = relX * sin + relZ * cos; // Check if within ship bounds if (Math.abs(localX) > width || Math.abs(localZ) > length / 2 || Math.abs(relY) > 15) { return null; } // Determine hit zone let zone = 'hull'; if (relY > 5) { zone = 'sails'; } else if (localZ > length * 0.4) { zone = Math.random() > 0.5 ? 'rudder' : 'hull'; } else if (Math.abs(localX) < width * 0.3 && localZ < -length * 0.3) { zone = Math.random() > 0.7 ? 'magazine' : 'hull'; } return { zone, localX, localZ, relY }; } onProjectileHit(proj, ship, hitZone, projIndex) { const ammoData = proj.ammoData; // Calculate damage based on zone and ammo type let damage = proj.damage; const zoneMultiplier = this.damageZones[hitZone.zone]?.multiplier || 1.0; // Apply ammo-specific damage multipliers switch (hitZone.zone) { case 'hull': damage *= ammoData.hullDamage * zoneMultiplier; break; case 'sails': damage *= ammoData.sailDamage * zoneMultiplier; ship.sailHealth = Math.max(0, (ship.sailHealth || 100) - damage); break; case 'crew': damage *= ammoData.crewDamage * zoneMultiplier; ship.crew = Math.max(0, ship.crew - Math.floor(damage / 10)); break; } // Apply damage ship.takeDamage(damage); this.stats.damageDealt += damage; // Apply special effects this.applyAmmoEffect(proj, ship, hitZone, ammoData); // Create hit effect this.createHitEffect(proj.position, ammoData.effect, hitZone.zone); // Remove projectile this.removeProjectile(proj, projIndex); // Camera shake for player if (ship.isPlayer) { this.game.camera?.shake(2, 0.3); this.stats.damageTaken += damage; } // Notification if (ship.isPlayer) { this.game.hud?.showNotification('Hit!', '-' + Math.round(damage) + ' Hull'); } else if (proj.owner?.isPlayer) { this.game.hud?.showNotification('Direct Hit!', '+' + Math.round(damage * 2) + ' Gold'); } } applyAmmoEffect(proj, ship, hitZone, ammoData) { switch (ammoData.effect) { case 'fire': case 'heated': this.startFire(ship, hitZone, ammoData.burnDuration || 5, ammoData.burnDamage || 10); break; case 'explosion': this.createExplosion(proj.position, ammoData.splashRadius || 15); // Area damage to nearby ships this.areaDamage(proj.position, ammoData.splashRadius || 15, ammoData.damage * 0.5, proj.owner); break; case 'sail_tear': ship.sailHealth = Math.max(0, (ship.sailHealth || 100) - 30); this.game.hud?.showNotification('Sails Damaged!', 'Enemy speed reduced'); break; } // Magazine hit = instant destruction if (hitZone.zone === 'magazine') { this.game.hud?.showNotification('MAGAZINE HIT!', 'Critical damage!'); ship.takeDamage(ship.maxHp * 0.5); this.createExplosion(ship.mesh.position, 30); } } // ============ SPECIAL EFFECTS ============ startFire(ship, hitZone, duration, damagePerSecond) { const fire = { ship: ship, position: hitZone, duration: duration, damage: damagePerSecond, particles: null }; // Create fire particles const particleCount = 30; const geometry = new THREE.BufferGeometry(); const positions = new Float32Array(particleCount * 3); for (let i = 0; i < particleCount; i++) { positions[i * 3] = (Math.random() - 0.5) * 5; positions[i * 3 + 1] = Math.random() * 3; positions[i * 3 + 2] = (Math.random() - 0.5) * 5; } geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); const material = new THREE.PointsMaterial({ color: 0xff4400, size: 1.5, transparent: true, opacity: 0.8 }); fire.particles = new THREE.Points(geometry, material); fire.particles.position.copy(ship.mesh.position); this.game.renderer.add(fire.particles); this.activeFires.push(fire); } updateEffects(dt) { // Update fires for (let i = this.activeFires.length - 1; i >= 0; i--) { const fire = this.activeFires[i]; fire.duration -= dt; if (fire.duration <= 0 || fire.ship.hp <= 0) { this.game.renderer.remove(fire.particles); this.activeFires.splice(i, 1); continue; } // Apply burn damage fire.ship.takeDamage(fire.damage * dt); // Update particle position fire.particles.position.copy(fire.ship.mesh.position); fire.particles.position.y += 5; // Animate particles const positions = fire.particles.geometry.attributes.position.array; for (let j = 0; j < positions.length / 3; j++) { positions[j * 3 + 1] += dt * 3; if (positions[j * 3 + 1] > 5) { positions[j * 3 + 1] = 0; } } fire.particles.geometry.attributes.position.needsUpdate = true; } } createExplosion(position, radius = 10) { // Particle explosion const particleCount = 100; const geometry = new THREE.BufferGeometry(); const positions = new Float32Array(particleCount * 3); const colors = new Float32Array(particleCount * 3); const velocities = []; for (let i = 0; i < particleCount; i++) { positions[i * 3] = position.x; positions[i * 3 + 1] = position.y; positions[i * 3 + 2] = position.z; // Orange to yellow gradient colors[i * 3] = 1.0; colors[i * 3 + 1] = 0.3 + Math.random() * 0.5; colors[i * 3 + 2] = 0; velocities.push(new THREE.Vector3( (Math.random() - 0.5) * 30, Math.random() * 20, (Math.random() - 0.5) * 30 )); } geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); const material = new THREE.PointsMaterial({ size: 2, vertexColors: true, transparent: true, opacity: 1 }); const particles = new THREE.Points(geometry, material); this.game.renderer.add(particles); // Animate explosion let lifetime = 1.5; const animateExplosion = () => { lifetime -= 0.016; if (lifetime <= 0) { this.game.renderer.remove(particles); return; } const positions = particles.geometry.attributes.position.array; for (let i = 0; i < velocities.length; i++) { velocities[i].y -= 15 * 0.016; positions[i * 3] += velocities[i].x * 0.016; positions[i * 3 + 1] += velocities[i].y * 0.016; positions[i * 3 + 2] += velocities[i].z * 0.016; } particles.geometry.attributes.position.needsUpdate = true; particles.material.opacity = lifetime / 1.5; requestAnimationFrame(animateExplosion); }; animateExplosion(); // Camera shake this.game.camera?.shake(5, 0.5); } createWaterSplash(position, big = false) { const splashCount = big ? 40 : 20; const geometry = new THREE.BufferGeometry(); const positions = new Float32Array(splashCount * 3); const velocities = []; for (let i = 0; i < splashCount; i++) { positions[i * 3] = position.x; positions[i * 3 + 1] = 0; positions[i * 3 + 2] = position.z; velocities.push(new THREE.Vector3( (Math.random() - 0.5) * (big ? 20 : 10), Math.random() * (big ? 30 : 20), (Math.random() - 0.5) * (big ? 20 : 10) )); } geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); const material = new THREE.PointsMaterial({ color: 0xffffff, size: big ? 2 : 1.5, transparent: true, opacity: 0.8 }); const particles = new THREE.Points(geometry, material); this.game.renderer.add(particles); let lifetime = 1; const animateSplash = () => { lifetime -= 0.016; if (lifetime <= 0) { this.game.renderer.remove(particles); return; } const positions = particles.geometry.attributes.position.array; for (let i = 0; i < velocities.length; i++) { velocities[i].y -= 25 * 0.016; positions[i * 3] += velocities[i].x * 0.016; positions[i * 3 + 1] += velocities[i].y * 0.016; positions[i * 3 + 2] += velocities[i].z * 0.016; } particles.geometry.attributes.position.needsUpdate = true; particles.material.opacity = lifetime; requestAnimationFrame(animateSplash); }; animateSplash(); } createHitEffect(position, effectType, zone) { // Small impact particles const count = effectType === 'explosion' ? 30 : 10; const geometry = new THREE.BufferGeometry(); const positions = new Float32Array(count * 3); const velocities = []; for (let i = 0; i < count; i++) { positions[i * 3] = position.x; positions[i * 3 + 1] = position.y; positions[i * 3 + 2] = position.z; velocities.push(new THREE.Vector3( (Math.random() - 0.5) * 10, Math.random() * 5, (Math.random() - 0.5) * 10 )); } geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); const color = zone === 'sails' ? 0xffffcc : effectType === 'fire' ? 0xff4400 : 0x888888; const material = new THREE.PointsMaterial({ color: color, size: 1, transparent: true, opacity: 0.8 }); const particles = new THREE.Points(geometry, material); this.game.renderer.add(particles); let lifetime = 0.5; const animate = () => { lifetime -= 0.016; if (lifetime <= 0) { this.game.renderer.remove(particles); return; } const positions = particles.geometry.attributes.position.array; for (let i = 0; i < velocities.length; i++) { positions[i * 3] += velocities[i].x * 0.016; positions[i * 3 + 1] += velocities[i].y * 0.016; positions[i * 3 + 2] += velocities[i].z * 0.016; velocities[i].y -= 10 * 0.016; } particles.geometry.attributes.position.needsUpdate = true; particles.material.opacity = lifetime * 2; requestAnimationFrame(animate); }; animate(); } areaDamage(position, radius, damage, owner) { for (const ship of this.game.ships) { if (ship === owner) continue; const distance = ship.mesh.position.distanceTo(position); if (distance < radius) { const falloff = 1 - (distance / radius); ship.takeDamage(damage * falloff); } } } removeProjectile(proj, index) { if (proj.mesh) { this.game.renderer.remove(proj.mesh); } const idx = this.projectiles.indexOf(proj); if (idx > -1) { this.projectiles.splice(idx, 1); } } // ============ BOARDING SYSTEM ============ initiateBoarding(playerShip, targetShip) { if (this.isBoarding) return false; // Check if close enough const distance = playerShip.mesh.position.distanceTo(targetShip.mesh.position); if (distance > 30) { this.game.hud?.showNotification('Too Far!', 'Get closer to board'); return false; } // Check if target is disabled (low health or sails destroyed) const isDisabled = targetShip.hp < targetShip.maxHp * 0.3 || (targetShip.sailHealth || 100) < 20; if (!isDisabled) { this.game.hud?.showNotification('Ship Not Disabled!', 'Damage hull or sails first'); return false; } this.isBoarding = true; this.boardingTarget = targetShip; // Create boarding UI this.createBoardingUI(playerShip, targetShip); this.game.hud?.showNotification('BOARDING!', 'Prepare for close quarters combat!'); return true; } createBoardingUI(playerShip, targetShip) { const overlay = document.createElement('div'); overlay.id = 'boarding-ui'; overlay.style.cssText = ` position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 300; `; overlay.innerHTML = ` <div style="font-size: 36px; color: #ffd700; margin-bottom: 20px;">‚öîÔ∏è BOARDING ACTION ‚öîÔ∏è</div> <div style="display: flex; gap: 100px; margin-bottom: 30px;"> <div style="text-align: center;"> <div style="font-size: 24px; color: #4488ff;">Your Crew</div> <div style="font-size: 48px; color: #fff;" id="player-crew">${playerShip.crew}</div> </div> <div style="font-size: 48px; color: #ffd700;">VS</div> <div style="text-align: center;"> <div style="font-size: 24px; color: #ff4444;">Enemy Crew</div> <div style="font-size: 48px; color: #fff;" id="enemy-crew">${targetShip.crew}</div> </div> </div> <div style="font-size: 18px; color: #aaa; margin-bottom: 20px;">Boarding in progress...</div> <div style="width: 300px; height: 20px; background: #333; border-radius: 10px; overflow: hidden;"> <div id="boarding-progress" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4488ff, #ffd700); transition: width 0.1s;"></div> </div> <div style="margin-top: 20px; display: flex; gap: 20px;"> <button onclick="window.boardingAction('attack')" style="padding: 15px 30px; font-size: 18px; background: rgba(255,100,100,0.3); border: 2px solid #ff6666; color: #ff6666; cursor: pointer;">‚öîÔ∏è Attack</button> <button onclick="window.boardingAction('defend')" style="padding: 15px 30px; font-size: 18px; background: rgba(100,100,255,0.3); border: 2px solid #6666ff; color: #6666ff; cursor: pointer;">üõ°Ô∏è Defend</button> <button onclick="window.boardingAction('retreat')" style="padding: 15px 30px; font-size: 18px; background: rgba(255,200,100,0.3); border: 2px solid #ffcc66; color: #ffcc66; cursor: pointer;">üèÉ Retreat</button> </div> `; document.body.appendChild(overlay); // Setup global boarding action window.boardingAction = (action) => this.handleBoardingAction(action); } handleBoardingAction(action) { if (!this.isBoarding) return; const player = this.game.player; const enemy = this.boardingTarget; switch (action) { case 'attack': // Player attacks const attackRoll = Math.random(); if (attackRoll > 0.4) { // Hit enemy.crew -= 5 + Math.floor(Math.random() * 5); this.game.hud?.showNotification('Attack Successful!', 'Enemy crew falling!'); } else { // Miss/Counter player.crew -= 3 + Math.floor(Math.random() * 3); this.game.hud?.showNotification('Attack Failed!', 'Counter attack!'); } break; case 'defend': // Defensive stance - reduce incoming damage const defendRoll = Math.random(); if (defendRoll > 0.6) { player.crew -= 1; this.game.hud?.showNotification('Defended!', 'Minimal losses'); } else { player.crew -= 2 + Math.floor(Math.random() * 2); } break; case 'retreat': // End boarding this.endBoarding(false); return; } // Update UI const playerCrewEl = document.getElementById('player-crew'); const enemyCrewEl = document.getElementById('enemy-crew'); if (playerCrewEl) playerCrewEl.textContent = player.crew; if (enemyCrewEl) enemyCrewEl.textContent = enemy.crew; // Check win/lose conditions if (enemy.crew <= 0) { this.endBoarding(true); } else if (player.crew <= 0) { this.endBoarding(false); } } updateBoarding(dt) { // Auto-progress boarding const progressBar = document.getElementById('boarding-progress'); if (progressBar) { const currentWidth = parseFloat(progressBar.style.width) || 0; progressBar.style.width = Math.min(100, currentWidth + dt * 5) + '%'; } // Random crew skirmishes if (Math.random() < 0.1) { const player = this.game.player; const enemy = this.boardingTarget; // Small random casualties player.crew = Math.max(0, player.crew - Math.floor(Math.random() * 2)); enemy.crew = Math.max(0, enemy.crew - Math.floor(Math.random() * 2)); // Update UI const playerCrewEl = document.getElementById('player-crew'); const enemyCrewEl = document.getElementById('enemy-crew'); if (playerCrewEl) playerCrewEl.textContent = player.crew; if (enemyCrewEl) enemyCrewEl.textContent = enemy.crew; } } endBoarding(victory) { this.isBoarding = false; // Remove UI const ui = document.getElementById('boarding-ui'); if (ui) ui.remove(); if (victory) { // Capture ship this.game.hud?.showNotification('VICTORY!', 'Ship captured!'); this.stats.boardingSuccess++; // Add to fleet or sink for gold const goldReward = this.boardingTarget.classData.cost * 0.3; this.game.hud?.showNotification('Prize Money!', '+' + Math.round(goldReward) + ' Gold'); this.stats.goldEarned += goldReward; // Remove enemy ship this.boardingTarget.sink(); } else { this.game.hud?.showNotification('Retreated!', 'Boarding failed'); } this.boardingTarget = null; } // ============ UTILITY ============ getStats() { return { ...this.stats, activeProjectiles: this.projectiles.length, activeFires: this.activeFires.length }; } }