// Caribbean Conquest - Input System // Handles keyboard, mouse, and touch controls class InputSystem { constructor(game) { this.game = game; // Key states this.keys = {}; this.keysPressed = {}; this.keysReleased = {}; // Mouse state this.mouse = { x: 0, y: 0, dx: 0, dy: 0, buttons: [false, false, false], wheel: 0 }; // Touch state this.touches = []; this.touchStart = null; // Control mappings this.keyBindings = { forward: ['w', 'ArrowUp'], backward: ['s', 'ArrowDown'], left: ['a', 'ArrowLeft'], right: ['d', 'ArrowRight'], fireLeft: ['q'], fireRight: ['e'], anchor: ['x'], repair: ['r'], map: ['m'], pause: ['Escape', 'p'], sprint: ['Shift'] }; // Callbacks this.callbacks = {}; } init() { // Keyboard events window.addEventListener('keydown', (e) => this.onKeyDown(e)); window.addEventListener('keyup', (e) => this.onKeyUp(e)); // Mouse events window.addEventListener('mousemove', (e) => this.onMouseMove(e)); window.addEventListener('mousedown', (e) => this.onMouseDown(e)); window.addEventListener('mouseup', (e) => this.onMouseUp(e)); window.addEventListener('wheel', (e) => this.onWheel(e)); // Touch events window.addEventListener('touchstart', (e) => this.onTouchStart(e)); window.addEventListener('touchmove', (e) => this.onTouchMove(e)); window.addEventListener('touchend', (e) => this.onTouchEnd(e)); // Context menu (prevent right-click menu) window.addEventListener('contextmenu', (e) => e.preventDefault()); // Blur event (reset keys when window loses focus) window.addEventListener('blur', () => this.resetKeys()); } onKeyDown(e) { const key = e.key.toLowerCase(); if (!this.keys[key]) { this.keysPressed[key] = true; } this.keys[key] = true; // Handle special keys this.handleKeyPress(key, e); } onKeyUp(e) { const key = e.key.toLowerCase(); this.keys[key] = false; this.keysReleased[key] = true; } onMouseMove(e) { this.mouse.dx = e.movementX || 0; this.mouse.dy = e.movementY || 0; this.mouse.x = e.clientX; this.mouse.y = e.clientY; } onMouseDown(e) { this.mouse.buttons[e.button] = true; } onMouseUp(e) { this.mouse.buttons[e.button] = false; } onWheel(e) { this.mouse.wheel = Math.sign(e.deltaY); // Zoom camera this.game.camera?.zoom(this.mouse.wheel); } onTouchStart(e) { this.touches = Array.from(e.touches).map(t => ({ x: t.clientX, y: t.clientY, id: t.identifier })); if (e.touches.length === 1) { this.touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY }; } } onTouchMove(e) { e.preventDefault(); this.touches = Array.from(e.touches).map(t => ({ x: t.clientX, y: t.clientY, id: t.identifier })); // Handle touch controls if (e.touches.length === 1 && this.touchStart) { const dx = e.touches[0].clientX - this.touchStart.x; const dy = e.touches[0].clientY - this.touchStart.y; // Update rudder based on horizontal drag const player = this.game.player; if (player) { player.rudderAngle = THREE.MathUtils.clamp(dx / 100, -1, 1); } } } onTouchEnd(e) { this.touches = Array.from(e.touches).map(t => ({ x: t.clientX, y: t.clientY, id: t.identifier })); if (e.touches.length === 0) { this.touchStart = null; // Reset rudder const player = this.game.player; if (player) { player.rudderAngle = 0; } } } handleKeyPress(key, e) { // Pause if (key === 'escape' || key === 'p') { if (this.game.isPaused) { this.game.resume(); } else { this.game.pause(); } } // Fire left cannons if (key === 'q') { this.game.player?.fireCannons('left'); this.game.hud?.flashAction('fire-left'); } // Fire right cannons if (key === 'e') { this.game.player?.fireCannons('right'); this.game.hud?.flashAction('fire-right'); } // Toggle anchor if (key === 'x') { const player = this.game.player; if (player) { player.anchorDown = !player.anchorDown; this.game.hud?.showNotification( player.anchorDown ? 'Anchor Down' : 'Anchor Raised', player.anchorDown ? 'Ship stopped' : 'Ready to sail' ); } } // Map if (key === 'm') { this.game.hud?.toggleMap(); } } isActionDown(action) { const bindings = this.keyBindings[action]; if (!bindings) return false; return bindings.some(key => this.keys[key.toLowerCase()]); } isActionPressed(action) { const bindings = this.keyBindings[action]; if (!bindings) return false; return bindings.some(key => this.keysPressed[key.toLowerCase()]); } isActionReleased(action) { const bindings = this.keyBindings[action]; if (!bindings) return false; return bindings.some(key => this.keysReleased[key.toLowerCase()]); } update(dt) { const player = this.game.player; if (!player) return; // Ship controls if (!player.anchorDown) { // Rudder control (turning) if (this.isActionDown('left')) { player.rudderAngle = Math.max(player.rudderAngle - 2 * dt, -1); } else if (this.isActionDown('right')) { player.rudderAngle = Math.min(player.rudderAngle + 2 * dt, 1); } else { // Return rudder to center player.rudderAngle *= 0.9; } // Forward/backward (sail adjustment) if (this.isActionDown('forward')) { // Raise sails - go faster player.targetSpeed = player.classData.maxSpeed; } else if (this.isActionDown('backward')) { // Lower sails - slow down player.targetSpeed = 0; } } // Clear per-frame states this.keysPressed = {}; this.keysReleased = {}; this.mouse.dx = 0; this.mouse.dy = 0; this.mouse.wheel = 0; } resetKeys() { this.keys = {}; this.keysPressed = {}; this.keysReleased = {}; } on(name, callback) { if (!this.callbacks[name]) { this.callbacks[name] = []; } this.callbacks[name].push(callback); } emit(name, data) { const callbacks = this.callbacks[name]; if (callbacks) { callbacks.forEach(cb => cb(data)); } } }