// Caribbean Conquest - AI System // Controls NPC ship behavior, combat AI, and pathfinding class AISystem { constructor(game) { this.game = game; // AI settings this.detectionRange = 500; this.combatRange = 300; this.fleeHealthPercent = 0.2; // Behavior states this.states = { IDLE: 'idle', PATROL: 'patrol', CHASE: 'chase', ATTACK: 'attack', FLEE: 'flee' }; } init() { // Initialize AI system } update(dt) { for (const ship of this.game.ships) { if (ship.isPlayer) continue; this.updateShipAI(ship, dt); } } updateShipAI(ship, dt) { // Get current state const state = this.determineState(ship); // Execute behavior switch (state) { case this.states.IDLE: this.executeIdle(ship, dt); break; case this.states.PATROL: this.executePatrol(ship, dt); break; case this.states.CHASE: this.executeChase(ship, dt); break; case this.states.ATTACK: this.executeAttack(ship, dt); break; case this.states.FLEE: this.executeFlee(ship, dt); break; } } determineState(ship) { const player = this.game.player; if (!player) return this.states.IDLE; const distanceToPlayer = ship.position.distanceTo(player.position); const healthPercent = ship.hp / ship.maxHp; // Flee if low health if (healthPercent < this.fleeHealthPercent) { return this.states.FLEE; } // Attack if in combat range if (distanceToPlayer < this.combatRange) { return this.states.ATTACK; } // Chase if detected player if (distanceToPlayer < this.detectionRange) { return this.states.CHASE; } // Patrol by default return this.states.PATROL; } executeIdle(ship, dt) { // Do nothing ship.rudderAngle = 0; ship.targetSpeed = 0; } executePatrol(ship, dt) { // Generate patrol points if needed if (ship.patrolPoints.length === 0) { this.generatePatrolPoints(ship); } // Move to current patrol point const target = ship.patrolPoints[ship.currentPatrolIndex]; if (!target) return; const distance = new THREE.Vector2( ship.position.x - target.x, ship.position.z - target.z ).length(); // Reached patrol point if (distance < 50) { ship.currentPatrolIndex = (ship.currentPatrolIndex + 1) % ship.patrolPoints.length; return; } // Steer towards patrol point this.steerTowards(ship, target); // Set speed ship.targetSpeed = ship.classData.maxSpeed * 0.5; } executeChase(ship, dt) { const player = this.game.player; if (!player) return; // Steer towards player this.steerTowards(ship, { x: player.position.x, z: player.position.z }); // Full speed ship.targetSpeed = ship.classData.maxSpeed; } executeAttack(ship, dt) { const player = this.game.player; if (!player) return; // Calculate angle to player const dx = player.position.x - ship.position.x; const dz = player.position.z - ship.position.z; const angleToPlayer = Math.atan2(dx, dz); const relativeAngle = this.normalizeAngle(angleToPlayer - ship.rotation); // Determine which side to fire from const angleThreshold = Math.PI / 4; // 45 degrees // Position for broadside if (Math.abs(relativeAngle) > Math.PI / 2 - angleThreshold && Math.abs(relativeAngle) < Math.PI / 2 + angleThreshold) { // We're in position to fire ship.targetSpeed = ship.classData.maxSpeed * 0.3; // Slow down for better aim // Fire cannons if (relativeAngle > 0) { ship.fireCannons('left'); } else { ship.fireCannons('right'); } } else { // Turn to get broadside position const targetAngle = angleToPlayer + (relativeAngle > 0 ? Math.PI / 2 : -Math.PI / 2); this.steerTowardsAngle(ship, targetAngle); ship.targetSpeed = ship.classData.maxSpeed * 0.5; } } executeFlee(ship, dt) { const player = this.game.player; if (!player) return; // Run away from player const fleeAngle = Math.atan2( ship.position.x - player.position.x, ship.position.z - player.position.z ); this.steerTowardsAngle(ship, fleeAngle); // Full speed away ship.targetSpeed = ship.classData.maxSpeed; } generatePatrolPoints(ship) { const count = 3 + Math.floor(Math.random() * 3); const radius = 200; const centerX = ship.position.x; const centerZ = ship.position.z; for (let i = 0; i < count; i++) { const angle = (i / count) * Math.PI * 2; ship.patrolPoints.push({ x: centerX + Math.cos(angle) * radius, z: centerZ + Math.sin(angle) * radius }); } } steerTowards(ship, target) { const dx = target.x - ship.position.x; const dz = target.z - ship.position.z; const targetAngle = Math.atan2(dx, dz); this.steerTowardsAngle(ship, targetAngle); } steerTowardsAngle(ship, targetAngle) { let angleDiff = this.normalizeAngle(targetAngle - ship.rotation); // Apply rudder if (angleDiff > 0.1) { ship.rudderAngle = Math.min(ship.rudderAngle + 0.02, 1); } else if (angleDiff < -0.1) { ship.rudderAngle = Math.max(ship.rudderAngle - 0.02, -1); } else { ship.rudderAngle *= 0.9; } } normalizeAngle(angle) { while (angle > Math.PI) angle -= Math.PI * 2; while (angle < -Math.PI) angle += Math.PI * 2; return angle; } }