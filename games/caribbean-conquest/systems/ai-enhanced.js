// Caribbean Conquest - Enhanced AI System // Phase 2: Advanced naval AI with formations, tactics, and fleet behavior class EnhancedAISystem { constructor(game) { this.game = game; // AI settings this.settings = { detectionRange: 600, combatRange: 350, optimalCombatRange: 200, fleeHealthPercent: 0.2, boardRange: 40, formationSpacing: 80 }; // Behavior states this.states = { IDLE: 'idle', PATROL: 'patrol', ESCORT: 'escort', CHASE: 'chase', ATTACK: 'attack', BOARDING: 'boarding', FLEE: 'flee', FORMATION: 'formation' }; // Faction behaviors this.factionBehaviors = { british: { aggression: 0.8, coordination: 0.9, fleeThreshold: 0.15 }, spanish: { aggression: 0.6, coordination: 0.7, fleeThreshold: 0.25 }, french: { aggression: 0.5, coordination: 0.6, fleeThreshold: 0.2 }, dutch: { aggression: 0.3, coordination: 0.5, fleeThreshold: 0.4 }, pirate: { aggression: 0.9, coordination: 0.4, fleeThreshold: 0.1 }, merchant: { aggression: 0.1, coordination: 0.3, fleeThreshold: 0.5 } }; // Fleet formations this.formations = { line: 'line', wedge: 'wedge', column: 'column', surround: 'surround' }; // Active fleets this.fleets = []; } init() { // Initialize AI system } update(dt) { // Update all ships for (const ship of this.game.ships) { if (ship.isPlayer) continue; this.updateShipAI(ship, dt); } // Update fleet coordination this.updateFleets(dt); } updateShipAI(ship, dt) { // Get current state const state = this.determineState(ship); // Execute behavior switch (state) { case this.states.IDLE: this.executeIdle(ship, dt); break; case this.states.PATROL: this.executePatrol(ship, dt); break; case this.states.CHASE: this.executeChase(ship, dt); break; case this.states.ATTACK: this.executeAttack(ship, dt); break; case this.states.BOARDING: this.executeBoarding(ship, dt); break; case this.states.FLEE: this.executeFlee(ship, dt); break; case this.states.FORMATION: this.executeFormation(ship, dt); break; case this.states.ESCORT: this.executeEscort(ship, dt); break; } } determineState(ship) { const player = this.game.player; if (!player) return this.states.IDLE; const distanceToPlayer = ship.position.distanceTo(player.position); const healthPercent = ship.hp / ship.maxHp; const factionBehavior = this.factionBehaviors[ship.faction] || this.factionBehaviors.pirate; // Flee if low health if (healthPercent < factionBehavior.fleeThreshold) { return this.states.FLEE; } // Boarding if close and player is disabled if (distanceToPlayer < this.settings.boardRange) { const playerDisabled = player.hp < player.maxHp * 0.3 || (player.sailHealth || 100) < 20; if (playerDisabled && ship.faction === 'pirate') { return this.states.BOARDING; } } // Attack if in combat range if (distanceToPlayer < this.settings.combatRange) { return this.states.ATTACK; } // Chase if detected player if (distanceToPlayer < this.settings.detectionRange) { if (Math.random() < factionBehavior.aggression) { return this.states.CHASE; } } // Check if part of fleet if (ship.fleet) { return this.states.FORMATION; } // Patrol by default return this.states.PATROL; } // ============ BEHAVIOR EXECUTION ============ executeIdle(ship, dt) { ship.rudderAngle = 0; ship.targetSpeed = 0; } executePatrol(ship, dt) { // Generate patrol points if needed if (ship.patrolPoints.length === 0) { this.generatePatrolPoints(ship); } // Move to current patrol point const target = ship.patrolPoints[ship.currentPatrolIndex]; if (!target) return; const distance = new THREE.Vector2( ship.position.x - target.x, ship.position.z - target.z ).length(); // Reached patrol point if (distance < 50) { ship.currentPatrolIndex = (ship.currentPatrolIndex + 1) % ship.patrolPoints.length; return; } // Steer towards patrol point this.steerTowards(ship, target); // Set speed ship.targetSpeed = ship.classData.maxSpeed * 0.5; } executeChase(ship, dt) { const player = this.game.player; if (!player) return; // Predict player position const predictTime = ship.position.distanceTo(player.position) / ship.classData.maxSpeed; const predictedPos = { x: player.position.x + player.velocity.x * predictTime * 0.5, z: player.position.z + player.velocity.z * predictTime * 0.5 }; // Steer towards predicted position this.steerTowards(ship, predictedPos); // Full speed ship.targetSpeed = ship.classData.maxSpeed; } executeAttack(ship, dt) { const player = this.game.player; if (!player) return; const distance = ship.position.distanceTo(player.position); // Calculate angle to player const dx = player.position.x - ship.position.x; const dz = player.position.z - ship.position.z; const angleToPlayer = Math.atan2(dx, dz); const relativeAngle = this.normalizeAngle(angleToPlayer - ship.rotation); // Choose ammunition type based on situation const ammoType = this.selectAmmunition(ship, player, distance); // Determine combat stance const stance = this.determineCombatStance(ship, player, distance); switch (stance) { case 'broadside': // Position for broadside this.positionForBroadside(ship, player, relativeAngle, dt); // Fire when in position if (Math.abs(relativeAngle) > Math.PI/2 - 0.3 && Math.abs(relativeAngle) < Math.PI/2 + 0.3) { const side = relativeAngle > 0 ? 'left' : 'right'; this.game.combat?.fireCannons(ship, side, ammoType); } break; case 'ram': // Head straight for player this.steerTowardsAngle(ship, angleToPlayer); ship.targetSpeed = ship.classData.maxSpeed; break; case 'kite': // Keep at range while firing this.maintainRange(ship, player, this.settings.optimalCombatRange, dt); break; case 'circle': // Circle around player this.circleTarget(ship, player, dt); break; } } executeBoarding(ship, dt) { const player = this.game.player; if (!player) return; // Move alongside player const offset = 20; // Distance to pull up alongside const targetAngle = Math.atan2( player.position.x - ship.position.x, player.position.z - ship.position.z ); // Approach from the side const approachAngle = targetAngle + Math.PI / 2; const targetPos = { x: player.position.x + Math.cos(approachAngle) * offset, z: player.position.z + Math.sin(approachAngle) * offset }; this.steerTowards(ship, targetPos); // Slow down when close const distance = ship.position.distanceTo(player.position); if (distance < 50) { ship.targetSpeed = ship.classData.maxSpeed * 0.3; } else { ship.targetSpeed = ship.classData.maxSpeed * 0.7; } } executeFlee(ship, dt) { const player = this.game.player; if (!player) return; // Run away from player const fleeAngle = Math.atan2( ship.position.x - player.position.x, ship.position.z - player.position.z ); // Add some randomness to avoid being predictable const randomOffset = (Math.random() - 0.5) * 0.5; this.steerTowardsAngle(ship, fleeAngle + randomOffset); // Full speed away ship.targetSpeed = ship.classData.maxSpeed; // Use chain shot to slow pursuer if being chased if (Math.random() < 0.3 && ship.ammo?.chain > 0) { const angleToPlayer = Math.atan2( player.position.x - ship.position.x, player.position.z - ship.position.z ); const relativeAngle = this.normalizeAngle(angleToPlayer - ship.rotation); const side = relativeAngle > 0 ? 'left' : 'right'; this.game.combat?.fireCannons(ship, side, 'chain'); } } executeFormation(ship, dt) { if (!ship.fleet || !ship.formationPosition) { return this.executePatrol(ship, dt); } // Get formation target position const targetPos = ship.formationPosition; this.steerTowards(ship, targetPos); // Match fleet speed ship.targetSpeed = ship.fleet.speed || ship.classData.maxSpeed * 0.7; } executeEscort(ship, dt) { if (!ship.escortTarget) { return this.executePatrol(ship, dt); } // Stay close to escort target const target = ship.escortTarget; const offset = ship.escortOffset || { x: 50, z: 0 }; const targetPos = { x: target.position.x + offset.x, z: target.position.z + offset.z }; this.steerTowards(ship, targetPos); // Match escort speed ship.targetSpeed = target.currentSpeed || target.classData.maxSpeed * 0.5; } // ============ TACTICAL HELPERS ============ selectAmmunition(ship, target, distance) { // Select best ammo based on situation const targetHealth = target.hp / target.maxHp; const targetSails = (target.sailHealth || 100) / 100; // Use chain shot to slow fast targets if (target.currentSpeed > ship.classData.maxSpeed * 0.8 && ship.ammo?.chain > 0) { return 'chain'; } // Use grape against low crew if (target.crew < target.maxCrew * 0.3 && ship.ammo?.grape > 0) { return 'grape'; } // Use explosive at close range if (distance < 150 && ship.ammo?.explosive > 0) { return 'explosive'; } // Default to round shot return 'round'; } determineCombatStance(ship, player, distance) { const healthRatio = ship.hp / ship.maxHp; const playerHealthRatio = player.hp / player.maxHp; // Aggressive if winning if (healthRatio > playerHealthRatio * 1.5) { return distance < 100 ? 'ram' : 'broadside'; } // Defensive if losing if (healthRatio < playerHealthRatio * 0.7) { return 'kite'; } // Balanced approach return 'broadside'; } positionForBroadside(ship, target, relativeAngle, dt) { const dx = target.position.x - ship.position.x; const dz = target.position.z - ship.position.z; const angleToTarget = Math.atan2(dx, dz); // We want to be perpendicular to the target const desiredAngle = angleToTarget + Math.PI / 2; // Turn to get broadside position this.steerTowardsAngle(ship, desiredAngle); // Maintain optimal range const distance = ship.position.distanceTo(target.position); if (distance > this.settings.optimalCombatRange + 50) { ship.targetSpeed = ship.classData.maxSpeed * 0.7; } else if (distance < this.settings.optimalCombatRange - 50) { ship.targetSpeed = ship.classData.maxSpeed * 0.3; } else { ship.targetSpeed = ship.classData.maxSpeed * 0.5; } } maintainRange(ship, target, desiredRange, dt) { const distance = ship.position.distanceTo(target.position); const dx = target.position.x - ship.position.x; const dz = target.position.z - ship.position.z; const angleToTarget = Math.atan2(dx, dz); if (distance < desiredRange - 30) { // Too close, back away const fleeAngle = angleToTarget + Math.PI; this.steerTowardsAngle(ship, fleeAngle); ship.targetSpeed = ship.classData.maxSpeed; } else if (distance > desiredRange + 30) { // Too far, close in this.steerTowardsAngle(ship, angleToTarget); ship.targetSpeed = ship.classData.maxSpeed; } else { // Good range, circle this.circleTarget(ship, target, dt); } } circleTarget(ship, target, dt) { const dx = target.position.x - ship.position.x; const dz = target.position.z - ship.position.z; const angleToTarget = Math.atan2(dx, dz); // Circle clockwise or counter-clockwise const circleDirection = ship.circleDirection || (Math.random() > 0.5 ? 1 : -1); ship.circleDirection = circleDirection; const circleAngle = angleToTarget + Math.PI / 2 * circleDirection; this.steerTowardsAngle(ship, circleAngle); ship.targetSpeed = ship.classData.maxSpeed * 0.6; } // ============ FLEET MANAGEMENT ============ createFleet(ships, formation = 'line') { const fleet = { id: Date.now(), ships: ships, formation: formation, leader: ships[0], speed: 0, target: null }; // Assign formation positions this.assignFormationPositions(fleet); this.fleets.push(fleet); // Assign fleet to ships for (const ship of ships) { ship.fleet = fleet; } return fleet; } assignFormationPositions(fleet) { const leader = fleet.leader; const spacing = this.settings.formationSpacing; switch (fleet.formation) { case 'line': for (let i = 0; i < fleet.ships.length; i++) { const ship = fleet.ships[i]; const offset = (i - Math.floor(fleet.ships.length / 2)) * spacing; ship.formationPosition = { x: leader.position.x - Math.cos(leader.rotation) * offset, z: leader.position.z - Math.sin(leader.rotation) * offset }; } break; case 'wedge': for (let i = 0; i < fleet.ships.length; i++) { const ship = fleet.ships[i]; const row = Math.floor(i / 2); const side = i % 2 === 0 ? -1 : 1; ship.formationPosition = { x: leader.position.x + Math.cos(leader.rotation + Math.PI/2) * side * spacing * (row + 1) - Math.sin(leader.rotation) * spacing * row, z: leader.position.z + Math.sin(leader.rotation + Math.PI/2) * side * spacing * (row + 1) - Math.cos(leader.rotation) * spacing * row }; } break; case 'column': for (let i = 0; i < fleet.ships.length; i++) { const ship = fleet.ships[i]; ship.formationPosition = { x: leader.position.x - Math.sin(leader.rotation) * spacing * i, z: leader.position.z - Math.cos(leader.rotation) * spacing * i }; } break; case 'surround': for (let i = 0; i < fleet.ships.length; i++) { const ship = fleet.ships[i]; const angle = (i / fleet.ships.length) * Math.PI * 2; ship.formationPosition = { x: leader.position.x + Math.cos(angle) * spacing * 2, z: leader.position.z + Math.sin(angle) * spacing * 2 }; } break; } } updateFleets(dt) { for (const fleet of this.fleets) { // Update formation positions based on leader movement this.assignFormationPositions(fleet); // Set fleet speed to slowest ship fleet.speed = Math.min(...fleet.ships.map(s => s.classData.maxSpeed)) * 0.7; } } // ============ UTILITY ============ generatePatrolPoints(ship) { const count = 3 + Math.floor(Math.random() * 3); const radius = 200 + Math.random() * 200; const centerX = ship.position.x; const centerZ = ship.position.z; for (let i = 0; i < count; i++) { const angle = (i / count) * Math.PI * 2; ship.patrolPoints.push({ x: centerX + Math.cos(angle) * radius, z: centerZ + Math.sin(angle) * radius }); } } steerTowards(ship, target) { const dx = target.x - ship.position.x; const dz = target.z - ship.position.z; const targetAngle = Math.atan2(dx, dz); this.steerTowardsAngle(ship, targetAngle); } steerTowardsAngle(ship, targetAngle) { let angleDiff = this.normalizeAngle(targetAngle - ship.rotation); // Apply rudder with smoothing const rudderSpeed = 2.0; if (angleDiff > 0.1) { ship.rudderAngle = Math.min(ship.rudderAngle + rudderSpeed * 0.016, 1); } else if (angleDiff < -0.1) { ship.rudderAngle = Math.max(ship.rudderAngle - rudderSpeed * 0.016, -1); } else { ship.rudderAngle *= 0.9; } } normalizeAngle(angle) { while (angle > Math.PI) angle -= Math.PI * 2; while (angle < -Math.PI) angle += Math.PI * 2; return angle; } }