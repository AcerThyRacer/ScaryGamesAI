// Caribbean Conquest - Combat System // Handles ship-to-ship combat, projectiles, and damage class CombatSystem { constructor(game) { this.game = game; // Projectile settings this.gravity = 9.8; this.projectileSpeed = 200; // Damage multipliers this.damageMultipliers = { hull: 1.0, sail: 0.3, crew: 0.2 }; // Combat effects this.explosions = []; this.splashes = []; } init() { // Initialize combat system } update(dt) { // Update all projectiles this.updateProjectiles(dt); // Update effects this.updateEffects(dt); } updateProjectiles(dt) { const projectiles = this.game.projectiles; for (let i = projectiles.length - 1; i >= 0; i--) { const proj = projectiles[i]; // Update lifetime proj.lifetime -= dt; if (proj.lifetime <= 0) { this.removeProjectile(proj, i); continue; } // Apply gravity to trajectory proj.velocity.y -= this.gravity * dt; // Update position proj.position.add(proj.velocity.clone().multiplyScalar(dt)); // Update mesh if (proj.mesh) { proj.mesh.position.copy(proj.position); } // Check for collisions this.checkCollisions(proj, i); } } checkCollisions(proj, projIndex) { // Check collision with ships for (const ship of this.game.ships) { if (ship === proj.owner) continue; if (this.checkShipCollision(proj, ship)) { this.onHit(proj, ship); this.removeProjectile(proj, projIndex); return; } } // Check collision with water if (proj.position.y < 0) { this.createSplash(proj.position); this.removeProjectile(proj, projIndex); } } checkShipCollision(proj, ship) { if (!ship.mesh) return false; // Simple bounding box collision const shipPos = ship.mesh.position; const { length, width } = ship.classData; const dx = Math.abs(proj.position.x - shipPos.x); const dz = Math.abs(proj.position.z - shipPos.z); const dy = Math.abs(proj.position.y - shipPos.y); return dx < length / 2 && dz < width / 2 && dy < 10; } onHit(proj, ship) { // Apply damage ship.takeDamage(proj.damage); // Create explosion effect this.createExplosion(proj.position); // Camera shake if player's ship if (ship.isPlayer) { this.game.camera?.shake(2, 0.3); } // Show notification if (ship.isPlayer) { this.game.hud?.showNotification('Hit!', '-' + proj.damage + ' Hull'); } else if (proj.owner?.isPlayer) { this.game.hud?.showNotification('Direct Hit!', '+' + Math.round(proj.damage * 10) + ' Gold'); } } removeProjectile(proj, index) { if (proj.mesh) { this.game.renderer.remove(proj.mesh); } this.game.projectiles.splice(index, 1); } createExplosion(position) { // Create particle explosion const particleCount = 50; const geometry = new THREE.BufferGeometry(); const positions = new Float32Array(particleCount * 3); const velocities = []; for (let i = 0; i < particleCount; i++) { positions[i * 3] = position.x; positions[i * 3 + 1] = position.y; positions[i * 3 + 2] = position.z; velocities.push(new THREE.Vector3( (Math.random() - 0.5) * 20, Math.random() * 15, (Math.random() - 0.5) * 20 )); } geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); const material = new THREE.PointsMaterial({ color: 0xff6600, size: 2, transparent: true, opacity: 1 }); const particles = new THREE.Points(geometry, material); this.game.renderer.add(particles); this.explosions.push({ mesh: particles, velocities, lifetime: 1, maxLifetime: 1 }); } createSplash(position) { const splashCount = 20; const geometry = new THREE.BufferGeometry(); const positions = new Float32Array(splashCount * 3); const velocities = []; for (let i = 0; i < splashCount; i++) { positions[i * 3] = position.x; positions[i * 3 + 1] = 0; positions[i * 3 + 2] = position.z; velocities.push(new THREE.Vector3( (Math.random() - 0.5) * 10, Math.random() * 20, (Math.random() - 0.5) * 10 )); } geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); const material = new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, transparent: true, opacity: 0.8 }); const particles = new THREE.Points(geometry, material); this.game.renderer.add(particles); this.splashes.push({ mesh: particles, velocities, lifetime: 0.8, maxLifetime: 0.8 }); } updateEffects(dt) { // Update explosions for (let i = this.explosions.length - 1; i >= 0; i--) { const exp = this.explosions[i]; exp.lifetime -= dt; if (exp.lifetime <= 0) { this.game.renderer.remove(exp.mesh); this.explosions.splice(i, 1); continue; } // Update particles const positions = exp.mesh.geometry.attributes.position.array; for (let j = 0; j < exp.velocities.length; j++) { exp.velocities[j].y -= 15 * dt; // Gravity positions[j * 3] += exp.velocities[j].x * dt; positions[j * 3 + 1] += exp.velocities[j].y * dt; positions[j * 3 + 2] += exp.velocities[j].z * dt; } exp.mesh.geometry.attributes.position.needsUpdate = true; exp.mesh.material.opacity = exp.lifetime / exp.maxLifetime; } // Update splashes for (let i = this.splashes.length - 1; i >= 0; i--) { const splash = this.splashes[i]; splash.lifetime -= dt; if (splash.lifetime <= 0) { this.game.renderer.remove(splash.mesh); this.splashes.splice(i, 1); continue; } const positions = splash.mesh.geometry.attributes.position.array; for (let j = 0; j < splash.velocities.length; j++) { splash.velocities[j].y -= 20 * dt; positions[j * 3] += splash.velocities[j].x * dt; positions[j * 3 + 1] += splash.velocities[j].y * dt; positions[j * 3 + 2] += splash.velocities[j].z * dt; } splash.mesh.geometry.attributes.position.needsUpdate = true; splash.mesh.material.opacity = splash.lifetime / splash.maxLifetime; } } }