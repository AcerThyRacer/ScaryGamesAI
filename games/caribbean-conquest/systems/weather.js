// Caribbean Conquest - Weather System // Dynamic weather with wind, storms, and fog class WeatherSystem { constructor(game) { this.game = game; // Current weather this.currentWeather = 'clear'; // 'clear', 'cloudy', 'storm', 'fog' this.stormIntensity = 0; // Wind this.wind = { direction: new THREE.Vector2(1, 0).normalize(), speed: 12, // knots baseSpeed: 12, gustTimer: 0, gustDuration: 0, gustStrength: 0 }; // Weather transition this.transitionTime = 0; this.transitionDuration = 60; // seconds // Weather patterns this.weatherPatterns = ['clear', 'clear', 'clear', 'cloudy', 'cloudy', 'storm', 'fog']; this.nextWeather = 'clear'; this.weatherTimer = 300; // Time until next weather change (5 min) // Rain particles this.rainParticles = null; this.rainIntensity = 0; // Fog this.fogDensity = 0.0008; } init() { // Initialize wind direction (random) const angle = Math.random() * Math.PI * 2; this.wind.direction.set(Math.cos(angle), Math.sin(angle)); // Create rain particle system this.createRain(); } createRain() { const rainCount = 10000; const positions = new Float32Array(rainCount * 3); const velocities = new Float32Array(rainCount); for (let i = 0; i < rainCount; i++) { positions[i * 3] = (Math.random() - 0.5) * 500; positions[i * 3 + 1] = Math.random() * 200; positions[i * 3 + 2] = (Math.random() - 0.5) * 500; velocities[i] = 0.5 + Math.random() * 0.5; } const geometry = new THREE.BufferGeometry(); geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); geometry.userData.velocities = velocities; const material = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.5, transparent: true, opacity: 0.6 }); this.rainParticles = new THREE.Points(geometry, material); this.rainParticles.visible = false; this.game.renderer.add(this.rainParticles); } update(dt) { // Update weather timer this.weatherTimer -= dt; if (this.weatherTimer <= 0) { this.changeWeather(); } // Update wind this.updateWind(dt); // Update weather effects this.updateWeatherEffects(dt); // Update rain position to follow player if (this.rainParticles && this.rainParticles.visible) { const player = this.game.player; if (player && player.mesh) { this.rainParticles.position.x = player.mesh.position.x; this.rainParticles.position.z = player.mesh.position.z; } this.updateRain(dt); } } updateWind(dt) { // Wind gusts this.wind.gustTimer -= dt; if (this.wind.gustTimer <= 0) { // Start new gust this.wind.gustDuration = 2 + Math.random() * 5; this.wind.gustTimer = this.wind.gustDuration + 5 + Math.random() * 10; this.wind.gustStrength = 0.2 + Math.random() * 0.5; } // Calculate current wind speed const gustFactor = this.wind.gustTimer > 0 && this.wind.gustTimer < this.wind.gustDuration ? Math.sin((this.wind.gustDuration - this.wind.gustTimer) / this.wind.gustDuration * Math.PI) * this.wind.gustStrength : 0; this.wind.speed = this.wind.baseSpeed * (1 + gustFactor + this.stormIntensity); // Slowly rotate wind direction const rotationSpeed = 0.01 * dt; const angle = Math.atan2(this.wind.direction.y, this.wind.direction.x); const newAngle = angle + rotationSpeed * (Math.random() - 0.5); this.wind.direction.set(Math.cos(newAngle), Math.sin(newAngle)).normalize(); // Update HUD const windSpeedEl = document.getElementById('wind-speed'); const windDirEl = document.getElementById('wind-dir'); const windArrow = document.getElementById('wind-arrow'); if (windSpeedEl) windSpeedEl.textContent = Math.round(this.wind.speed) + ' kts'; if (windDirEl) { const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']; const dirIndex = Math.round((newAngle + Math.PI) / (Math.PI / 4)) % 8; windDirEl.textContent = directions[dirIndex] + ' Winds'; } if (windArrow) { windArrow.style.transform = `rotate(${newAngle}rad)`; } } updateWeatherEffects(dt) { // Transition weather if (this.transitionTime > 0) { this.transitionTime -= dt; const t = 1 - (this.transitionTime / this.transitionDuration); if (this.currentWeather === 'storm' || this.nextWeather === 'storm') { this.stormIntensity = this.currentWeather === 'storm' ? 1 - t : t; } if (this.currentWeather === 'fog' || this.nextWeather === 'fog') { this.fogDensity = this.currentWeather === 'fog' ? 0.003 * (1 - t) + 0.0008 * t : 0.0008 * (1 - t) + 0.003 * t; this.game.renderer.scene.fog.density = this.fogDensity; } if (this.currentWeather === 'storm' || this.nextWeather === 'storm') { this.rainIntensity = this.currentWeather === 'storm' ? 1 - t : t; this.rainParticles.visible = this.rainIntensity > 0.1; } if (this.transitionTime <= 0) { this.currentWeather = this.nextWeather; } } } updateRain(dt) { const positions = this.rainParticles.geometry.attributes.position.array; const velocities = this.rainParticles.geometry.userData.velocities; for (let i = 0; i < positions.length / 3; i++) { positions[i * 3 + 1] -= velocities[i] * 100 * dt * this.rainIntensity; // Reset rain drops that fall below ground if (positions[i * 3 + 1] < 0) { positions[i * 3 + 1] = 200; positions[i * 3] = (Math.random() - 0.5) * 500; positions[i * 3 + 2] = (Math.random() - 0.5) * 500; } } this.rainParticles.geometry.attributes.position.needsUpdate = true; } changeWeather() { // Pick new weather this.nextWeather = this.weatherPatterns[Math.floor(Math.random() * this.weatherPatterns.length)]; if (this.nextWeather !== this.currentWeather) { this.transitionTime = this.transitionDuration; } // Set timer for next change this.weatherTimer = 180 + Math.random() * 300; // 3-8 minutes // Show notification for storms if (this.nextWeather === 'storm' && this.currentWeather !== 'storm') { this.game.hud?.showNotification('Storm Approaching!', 'Prepare for rough seas'); } } }