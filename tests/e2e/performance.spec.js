/** * Performance E2E Tests * Phase 1: Testing Infrastructure Expansion * * Tests for Core Web Vitals and performance budgets */ const { test, expect } = require('@playwright/test'); test.describe('Performance Tests', () => { test('homepage should meet Core Web Vitals', async ({ page }) => { // Navigate and measure await page.goto('/', { waitUntil: 'networkidle' }); // Measure First Contentful Paint (FCP) const fcp = await page.evaluate(() => { const entries = performance.getEntriesByType('paint'); const fcpEntry = entries.find(e => e.name === 'first-contentful-paint'); return fcpEntry ? fcpEntry.startTime : 0; }); // FCP should be under 1.8s (Google's "good" threshold) expect(fcp).toBeLessThan(1800); // Measure Largest Contentful Paint (LCP) const lcp = await page.evaluate(() => { return new Promise((resolve) => { new PerformanceObserver((list) => { const entries = list.getEntries(); const lastEntry = entries[entries.length - 1]; resolve(lastEntry.startTime); }).observe({ type: 'largest-contentful-paint', buffered: true }); // Fallback timeout setTimeout(() => resolve(0), 5000); }); }); // LCP should be under 2.5s (Google's "good" threshold) expect(lcp).toBeLessThan(2500); }); test('homepage should load quickly', async ({ page }) => { const startTime = Date.now(); await page.goto('/', { waitUntil: 'domcontentloaded' }); const loadTime = Date.now() - startTime; // Page should load in under 3 seconds expect(loadTime).toBeLessThan(3000); }); test('game page should load within budget', async ({ page }) => { const startTime = Date.now(); await page.goto('/games/the-abyss/the-abyss.html', { waitUntil: 'domcontentloaded' }); const loadTime = Date.now() - startTime; // Game pages have larger assets, allow 5 seconds expect(loadTime).toBeLessThan(5000); }); test('should not have JavaScript errors', async ({ page }) => { const errors = []; page.on('pageerror', (error) => { errors.push(error.message); }); await page.goto('/'); await page.waitForTimeout(2000); // Wait for any delayed errors expect(errors.length).toBe(0); }); test('should not have console errors', async ({ page }) => { const consoleErrors = []; page.on('console', (msg) => { if (msg.type() === 'error') { consoleErrors.push(msg.text()); } }); await page.goto('/'); await page.waitForTimeout(2000); // Filter out known non-critical errors const criticalErrors = consoleErrors.filter(err => !err.includes('favicon') && !err.includes('manifest') && !err.includes('404') ); expect(criticalErrors.length).toBe(0); }); test('should have efficient bundle sizes', async ({ page }) => { await page.goto('/'); // Get all JavaScript resources const jsResources = await page.evaluate(() => { const entries = performance.getEntriesByType('resource'); return entries .filter(e => e.name.endsWith('.js')) .map(e => ({ name: e.name.split('/').pop(), size: e.transferSize || e.encodedBodySize, })); }); // Calculate total JS size const totalJsSize = jsResources.reduce((sum, r) => sum + r.size, 0); // Total JS should be under 1.5MB expect(totalJsSize).toBeLessThan(1500000); // No single bundle should be over 500KB (except Three.js) const largeBundles = jsResources.filter(r => r.size > 500000 && !r.name.includes('three')); expect(largeBundles.length).toBe(0); }); test('should have efficient CSS sizes', async ({ page }) => { await page.goto('/'); // Get all CSS resources const cssResources = await page.evaluate(() => { const entries = performance.getEntriesByType('resource'); return entries .filter(e => e.name.endsWith('.css')) .map(e => ({ name: e.name.split('/').pop(), size: e.transferSize || e.encodedBodySize, })); }); // Calculate total CSS size const totalCssSize = cssResources.reduce((sum, r) => sum + r.size, 0); // Total CSS should be under 200KB expect(totalCssSize).toBeLessThan(200000); }); test('should have reasonable number of requests', async ({ page }) => { await page.goto('/', { waitUntil: 'networkidle' }); const requestCount = await page.evaluate(() => { const entries = performance.getEntriesByType('resource'); return entries.length; }); // Should have fewer than 100 requests on homepage expect(requestCount).toBeLessThan(100); }); test('should use cached resources on repeat visit', async ({ page }) => { // First visit await page.goto('/', { waitUntil: 'networkidle' }); // Second visit await page.goto('/', { waitUntil: 'networkidle' }); // Check cache hit ratio const cacheStats = await page.evaluate(() => { const entries = performance.getEntriesByType('resource'); const cached = entries.filter(e => e.transferSize === 0 && e.decodedBodySize > 0); return { total: entries.length, cached: cached.length, ratio: cached.length / entries.length, }; }); // At least 50% should be cached on repeat visit expect(cacheStats.ratio).toBeGreaterThan(0.5); }); test('should have good Time to Interactive', async ({ page }) => { const startTime = Date.now(); await page.goto('/'); // Wait for main content to be interactive await page.waitForSelector('.game-card', { state: 'visible' }); await page.waitForFunction(() => { // Check if main scripts have loaded return document.querySelector('.game-card canvas') !== null; }); const tti = Date.now() - startTime; // TTI should be under 3.5 seconds expect(tti).toBeLessThan(3500); }); test('should handle slow network gracefully', async ({ page }) => { // Simulate slow 3G await page.route('**/*', async (route) => { await new Promise(resolve => setTimeout(resolve, 100)); route.continue(); }); const startTime = Date.now(); await page.goto('/', { waitUntil: 'domcontentloaded', timeout: 30000 }); const loadTime = Date.now() - startTime; // Should still load within 10 seconds on slow network expect(loadTime).toBeLessThan(10000); // Check that content is visible const heroTitle = page.locator('h1').first(); await expect(heroTitle).toBeVisible(); }); }); test.describe('Memory Performance Tests', () => { test('should not have memory leaks on homepage', async ({ page }) => { await page.goto('/'); // Force garbage collection if available await page.evaluate(() => { if (window.gc) window.gc(); }); // Get initial memory const initialMemory = await page.evaluate(() => { return performance.memory ? performance.memory.usedJSHeapSize : 0; }); // Interact with page for (let i = 0; i < 5; i++) { await page.reload(); await page.waitForSelector('.game-card', { timeout: 10000 }); } // Force garbage collection again await page.evaluate(() => { if (window.gc) window.gc(); }); // Get final memory const finalMemory = await page.evaluate(() => { return performance.memory ? performance.memory.usedJSHeapSize : 0; }); // Memory should not have grown significantly (allow 50% growth) if (initialMemory > 0) { const growth = (finalMemory - initialMemory) / initialMemory; expect(growth).toBeLessThan(0.5); } }); });