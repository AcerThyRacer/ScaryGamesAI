/** * HLS Adaptive Video Player * Phase 1: Asset Pipeline Modernization * * Features: * - Adaptive bitrate streaming based on network conditions * - Fallback to native MP4 for browsers without HLS support * - Automatic quality selection * - Network condition monitoring * - Mobile-optimized playback */ class HLSVideoPlayer { constructor(options = {}) { this.container = options.container; this.videoElement = options.videoElement; this.hlsSources = options.hlsSources || []; this.mp4Fallback = options.mp4Fallback; this.autoplay = options.autoplay !== false; this.muted = options.muted !== false; this.loop = options.loop !== false; this.poster = options.poster; this.onReady = options.onReady || (() => {}); this.onError = options.onError || (() => {}); this.onQualityChange = options.onQualityChange || (() => {}); this.hls = null; this.currentQuality = 'auto'; this.networkMonitor = null; this.init(); } /** * Initialize the video player */ async init() { if (!this.videoElement) { console.error('[HLSPlayer] No video element provided'); return; } // Check for HLS support const hlsSupported = this.checkHLSSupport(); if (hlsSupported && this.hlsSources.length > 0) { await this.initHLS(); } else if (this.mp4Fallback) { this.initFallback(); } else { console.warn('[HLSPlayer] No playable sources available'); } // Set common attributes this.videoElement.muted = this.muted; this.videoElement.loop = this.loop; this.videoElement.playsInline = true; if (this.poster) { this.videoElement.poster = this.poster; } // Start network monitoring this.startNetworkMonitor(); } /** * Check if browser supports HLS */ checkHLSSupport() { // Native HLS support (Safari) if (this.videoElement.canPlayType('application/vnd.apple.mpegurl')) { return 'native'; } // HLS.js support if (typeof Hls !== 'undefined' && Hls.isSupported()) { return 'hlsjs'; } return false; } /** * Initialize HLS.js player */ async initHLS() { const supportType = this.checkHLSSupport(); if (supportType === 'native') { // Safari native HLS const source = this.hlsSources[0]; this.videoElement.src = source; this.videoElement.addEventListener('loadedmetadata', () => { this.onReady({ type: 'native', quality: 'auto' }); }); this.videoElement.addEventListener('error', (e) => { this.onError(e); this.initFallback(); }); } else if (supportType === 'hlsjs') { // HLS.js try { this.hls = new Hls({ enableWorker: true, lowLatencyMode: false, backBufferLength: 90, maxBufferLength: 30, maxMaxBufferLength: 60, startLevel: -1, // Auto capLevelToPlayerSize: true, // Adjust quality based on player size }); // Bind events this.hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => { this.onReady({ type: 'hlsjs', levels: data.levels.length, quality: 'auto' }); if (this.autoplay) { this.videoElement.play().catch(() => {}); } }); this.hls.on(Hls.Events.ERROR, (event, data) => { if (data.fatal) { switch (data.type) { case Hls.ErrorTypes.NETWORK_ERROR: console.error('[HLSPlayer] Network error, trying to recover...'); this.hls.startLoad(); break; case Hls.ErrorTypes.MEDIA_ERROR: console.error('[HLSPlayer] Media error, trying to recover...'); this.hls.recoverMediaError(); break; default: console.error('[HLSPlayer] Fatal error, falling back to MP4'); this.onError(data); this.initFallback(); break; } } }); this.hls.on(Hls.Events.LEVEL_SWITCHED, (event, data) => { const level = this.hls.levels[data.level]; this.currentQuality = level ? `${level.height}p` : 'auto'; this.onQualityChange({ quality: this.currentQuality, bitrate: level ? level.bitrate : 0, width: level ? level.width : 0, height: level ? level.height : 0, }); }); // Load source const source = this.hlsSources[0]; this.hls.loadSource(source); this.hls.attachMedia(this.videoElement); } catch (e) { console.error('[HLSPlayer] HLS.js initialization failed:', e); this.initFallback(); } } } /** * Initialize fallback MP4 playback */ initFallback() { if (this.hls) { this.hls.destroy(); this.hls = null; } if (this.mp4Fallback) { this.videoElement.src = this.mp4Fallback; this.videoElement.addEventListener('loadedmetadata', () => { this.onReady({ type: 'mp4', quality: 'fallback' }); if (this.autoplay) { this.videoElement.play().catch(() => {}); } }); } } /** * Start network condition monitoring */ startNetworkMonitor() { // Use Network Information API if available if ('connection' in navigator) { this.networkMonitor = navigator.connection; this.networkMonitor.addEventListener('change', this.handleNetworkChange.bind(this)); } // Periodic bandwidth estimation this.bandwidthInterval = setInterval(() => { this.estimateBandwidth(); }, 10000); } /** * Handle network condition changes */ handleNetworkChange() { if (!this.hls) return; const connection = navigator.connection; if (!connection) return; const effectiveType = connection.effectiveType; // Adjust quality based on connection type switch (effectiveType) { case '4g': // High quality this.hls.currentLevel = -1; // Auto break; case '3g': // Medium quality this.hls.currentLevel = Math.min(1, this.hls.levels.length - 1); break; case '2g': case 'slow-2g': // Low quality this.hls.currentLevel = 0; break; } } /** * Estimate available bandwidth */ async estimateBandwidth() { if (!this.hls || !this.hls.levels) return; const stats = this.hls.bandwidthEstimate; // Store bandwidth estimate for analytics this.lastBandwidthEstimate = stats; } /** * Get current playback quality */ getQuality() { return { current: this.currentQuality, available: this.hls ? this.hls.levels.map((l, i) => ({ index: i, height: l.height, bitrate: l.bitrate, })) : [], bandwidth: this.lastBandwidthEstimate || 0, }; } /** * Set playback quality * @param {number|string} quality - Quality index or 'auto' */ setQuality(quality) { if (!this.hls) return; if (quality === 'auto') { this.hls.currentLevel = -1; } else { this.hls.currentLevel = parseInt(quality); } } /** * Play video */ async play() { try { await this.videoElement.play(); } catch (e) { console.warn('[HLSPlayer] Play failed:', e); } } /** * Pause video */ pause() { this.videoElement.pause(); } /** * Destroy player */ destroy() { if (this.hls) { this.hls.destroy(); this.hls = null; } if (this.networkMonitor) { this.networkMonitor.removeEventListener('change', this.handleNetworkChange); } if (this.bandwidthInterval) { clearInterval(this.bandwidthInterval); } } } /** * HLS Video Background Component * For hero section background videos with adaptive streaming */ class HLSVideoBackground { constructor(options = {}) { this.container = options.container; this.videos = options.videos || []; this.currentIndex = 0; this.players = []; this.crossfadeDuration = options.crossfadeDuration || 1600; this.onVideoChange = options.onVideoChange || (() => {}); this.init(); } /** * Initialize video background */ async init() { if (!this.container || this.videos.length === 0) return; // Create video elements this.videos.forEach((video, index) => { const videoEl = document.createElement('video'); videoEl.className = 'bg-video'; videoEl.id = `bg-video-${index}`; videoEl.muted = true; videoEl.playsInline = true; videoEl.loop = false; // We'll handle looping manually videoEl.style.cssText = ` position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; opacity: 0; transition: opacity ${this.crossfadeDuration}ms ease-in-out; `; this.container.appendChild(videoEl); const player = new HLSVideoPlayer({ videoElement: videoEl, hlsSources: video.hls ? [video.hls] : [], mp4Fallback: video.mp4, poster: video.poster, autoplay: false, muted: true, loop: false, onReady: () => { if (index === 0) { this.startPlayback(); } }, }); this.players.push(player); }); } /** * Start playback from first video */ startPlayback() { if (this.players.length === 0) return; this.playVideo(0); } /** * Play specific video by index */ playVideo(index) { const player = this.players[index]; if (!player) return; const videoEl = player.videoElement; // Fade in current video videoEl.style.opacity = '1'; videoEl.classList.add('active'); player.play(); // Set up ended handler for crossfade videoEl.onended = () => { this.crossfadeToNext(); }; this.currentIndex = index; this.onVideoChange({ index, video: this.videos[index] }); } /** * Crossfade to next video */ crossfadeToNext() { const currentEl = this.players[this.currentIndex].videoElement; const nextIndex = (this.currentIndex + 1) % this.players.length; const nextEl = this.players[nextIndex].videoElement; // Reset next video nextEl.currentTime = 0; // Fade out current, fade in next currentEl.style.opacity = '0'; currentEl.classList.remove('active'); nextEl.style.opacity = '1'; nextEl.classList.add('active'); this.players[nextIndex].play(); // Pause old video after transition setTimeout(() => { currentEl.pause(); currentEl.currentTime = 0; }, this.crossfadeDuration); // Set up ended handler for next video nextEl.onended = () => { this.crossfadeToNext(); }; this.currentIndex = nextIndex; this.onVideoChange({ index: nextIndex, video: this.videos[nextIndex] }); } /** * Destroy all players */ destroy() { this.players.forEach(player => player.destroy()); this.players = []; } } /** * Initialize HLS video backgrounds from index */ async function initHLSVideoBackgrounds() { // Check for reduced motion preference const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches; if (prefersReducedMotion) { console.log('[HLSPlayer] Reduced motion preferred, skipping video backgrounds'); return; } // Fetch HLS index try { const response = await fetch('/assets/hls/index.json'); if (!response.ok) { console.warn('[HLSPlayer] HLS index not found, using MP4 fallback'); return null; } const data = await response.json(); // Return video data for use by video background component return data.videos; } catch (e) { console.warn('[HLSPlayer] Could not load HLS index:', e); return null; } } // Export for use if (typeof module !== 'undefined' && module.exports) { module.exports = { HLSVideoPlayer, HLSVideoBackground, initHLSVideoBackgrounds, }; } else if (typeof window !== 'undefined') { window.HLSVideoPlayer = HLSVideoPlayer; window.HLSVideoBackground = HLSVideoBackground; window.initHLSVideoBackgrounds = initHLSVideoBackgrounds; }